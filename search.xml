<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>什么是 SLA</title>
      <link href="/2021/10/18/%E5%8F%AF%E9%9D%A0%E6%80%A7/SLA/what_is_sla/"/>
      <url>/2021/10/18/%E5%8F%AF%E9%9D%A0%E6%80%A7/SLA/what_is_sla/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>应将工程时间用于最重要服务的最重要功能 </p></blockquote><a id="more"></a><h2 id="服务质量协议-SLA"><a href="#服务质量协议-SLA" class="headerlink" title="服务质量协议(SLA)"></a>服务质量协议(SLA)</h2><blockquote><p>SLI: Service Level Agreement</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>定义</strong> <em>服务等级协议、服务水平协议，是服务提供商与客户之间定义的正式承诺。</em></p><p><strong>特点</strong></p><ul><li>服务提供商与受服务用户之间具体达成了承诺的服务指标: 质量、可用性，责任。</li></ul><p><strong>描述</strong></p><ul><li>SLA = SLO + 后果</li></ul><p><strong>意义</strong> </p><ul><li>便于提升实践项目的实施质量</li><li>便于降低实践项目的修改率与质疑率</li><li>加强了实践项目的协作关系</li></ul>]]></content>
      
      
      <categories>
          
          <category> 可靠性 </category>
          
          <category> SLA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可靠性 </tag>
            
            <tag> SLA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 SLI</title>
      <link href="/2021/10/18/%E5%8F%AF%E9%9D%A0%E6%80%A7/SLI/what_is_sli/"/>
      <url>/2021/10/18/%E5%8F%AF%E9%9D%A0%E6%80%A7/SLI/what_is_sli/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>应将工程时间用于最重要服务的最重要功能 </p></blockquote><a id="more"></a><h2 id="服务质量指标-SLI"><a href="#服务质量指标-SLI" class="headerlink" title="服务质量指标(SLI)"></a>服务质量指标(SLI)</h2><blockquote><p>SLI: Service Level Indicator</p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>定义</strong> <em>该服务的某项服务质量的一个具体量化指标。</em></p><p><strong>特点</strong></p><ul><li>随着时间变化的度量值</li></ul><p><strong>意义</strong><br><em>通过 SLI 测量出服务的质量指标，该值用于描述 SLO</em></p><p><strong>示例</strong> </p><ul><li>请求计数：5分钟内慢查询数量、每分钟慢请求数量。</li><li>响应延迟时间：慢查询的执行时间、慢请求的响应延迟</li></ul><img src="/2021/10/18/%E5%8F%AF%E9%9D%A0%E6%80%A7/SLI/what_is_sli/img.png" class="" title="[1] SLI计算公式"><h3 id="可测量指标分类"><a href="#可测量指标分类" class="headerlink" title="可测量指标分类"></a>可测量指标分类</h3><ul><li>性能<ul><li>响应时间(latency)</li><li>吞吐量(throughput)</li><li>请求量(qps)</li><li>实效性(freshness)</li></ul></li><li>可用性<ul><li>运行时间(uptime)</li><li>故障时间/频率</li><li>高可用</li></ul></li><li>质量<ul><li>准确性(accuracy)</li><li>正确性(correctness)</li><li>完整性(completeness)</li><li>覆盖率(coverage)</li><li>相关性(relevance)</li></ul></li><li>内部指标<ul><li>队列长度(queue length)</li><li>内存占用(RAM usage)</li></ul></li><li>因素<ul><li>响应时间(time to response)</li><li>修复时间(time to fix)</li><li>修复率(fraction fixed)</li></ul></li></ul><p><strong>常见问题</strong></p><ul><li>要测量的指标是什么？ </li><li>测量时的系统状态？ </li><li>如何汇总处理测量的指标？ </li><li>测量指标能否准确描述服务质量？ </li><li>测量指标的可靠度(trustworthy)？</li></ul><blockquote><p>不同类型组建的潜在SLI：可用性、延迟、质量、时效性、正确率、覆盖率、持久性</p></blockquote><p><strong>举例说明：</strong> <em>hotmail的downtime SLI</em></p><blockquote><p>错误率(error rate)计算的是服务返回给用户的error总数<br>如果错误率大于X%，就算是服务down了，开始计算downtime<br>如果错误率持续超过Y分钟，这个downtime就会被计算在内<br>间断性的小于Y分钟的downtime是不被计算在内的。</p></blockquote><h3 id="测量时的系统状态，在什么情况下测量会严重影响测量的结果"><a href="#测量时的系统状态，在什么情况下测量会严重影响测量的结果" class="headerlink" title="测量时的系统状态，在什么情况下测量会严重影响测量的结果"></a>测量时的系统状态，在什么情况下测量会严重影响测量的结果</h3><ul><li>测量异常(badly-formed)请求，还是失败(fail)请求还是超时请求(timeout)</li><li>测量时的系统负载（是否最大负载）</li><li>测量的发起位置，服务器端还是客户端</li><li>测量的时间窗口（仅工作日、还是一周7天、是否包括计划内的维护时间段）</li><li><h3 id="如何汇总处理测量的指标？"><a href="#如何汇总处理测量的指标？" class="headerlink" title="如何汇总处理测量的指标？"></a>如何汇总处理测量的指标？</h3></li><li>计算的时间区间是什么：是一个滚动时间窗口，还是简单的按照月份计算</li><li>使用平均值还是百分位值，比如：某服务 X 的 ticket 处理响应时间 SLI 的</li><li>测量指标：统计所有成功解决请求，从用户创建 ticket到问题被解决的时间</li><li>怎么测量：用 ticket 自带的时间戳，统计所有用户创建的 ticket</li><li>什么情况下的测量：只包括工作时间，不包含法定假日</li><li>用于SLI的数据指标：以一周为滑动窗口，95%分位的解决时间</li></ul><h3 id="测量指标能否准确描述服务质量？"><a href="#测量指标能否准确描述服务质量？" class="headerlink" title="测量指标能否准确描述服务质量？"></a>测量指标能否准确描述服务质量？</h3><ul><li>性能：时效性、是否有偏差</li><li>准确性：精度、覆盖率、数据稳定性</li><li>完整性：数据丢失、无效数据、异常(outlier)数据</li></ul><h3 id="测量指标的可靠度"><a href="#测量指标的可靠度" class="headerlink" title="测量指标的可靠度"></a>测量指标的可靠度</h3><ul><li>是否服务提供者和客户都认可</li><li>是否可被独立验证，比如三方机构</li><li>客户端还是服务器端测量，取样间隔</li><li>错误请求是如何计算的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 可靠性 </category>
          
          <category> SLI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可靠性 </tag>
            
            <tag> SLI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 SLO</title>
      <link href="/2021/10/11/%E5%8F%AF%E9%9D%A0%E6%80%A7/SLO/why_need_slo/"/>
      <url>/2021/10/11/%E5%8F%AF%E9%9D%A0%E6%80%A7/SLO/why_need_slo/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>应将工程时间用于最重要服务的最重要功能 </p></blockquote><a id="more"></a><p><a href="/2021/10/18/可靠性/SLI/what_is_sli/">服务质量指标(SLI)</a></p><h2 id="服务水平目标-SLO"><a href="#服务水平目标-SLO" class="headerlink" title="服务水平目标(SLO)"></a>服务水平目标(SLO)</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>SLO: Service Level Objective</p></blockquote><p><strong>定义</strong> <em>指服务可靠性的目标水平，指定了服务所提供功能的一种期望状态。</em><br><strong>意义</strong> </p><ul><li><em>由于 SLO 是做出以数据为依据的可靠性决策的关键，因此它们是SRE实践的核心。</em></li><li><em>服务提供者用它来指定系统的预期状态;</em></li><li><em>开发人员编写代码来实现;</em></li><li><em>客户依赖于 SLO 进行商业判断。</em></li></ul><p><strong>示例</strong></p><ul><li>每分钟慢查询数量 &lt; 10</li><li>99% 访问延迟 &lt; 100ms</li><li>99% 每分QPS &gt; 10k/s</li></ul><p><strong>SLO 几个最佳实践</strong></p><ul><li>明确指定计算的时间窗口</li><li>使用一致的时间窗口（例如：5min滚动窗口、15min滚动窗口、1h滚动窗口、24h级滚动窗口）</li><li>需要有免责条款（例如：95%的慢查询要达到SLO、95%的访问延迟要达到SLO）</li></ul><h3 id="遵循原则"><a href="#遵循原则" class="headerlink" title="遵循原则"></a>遵循原则</h3><ul><li>测量系统当前状态 <ul><li>设置预期(expectations)，而不是保证(guarantees)</li><li>初期的 SLO 不适合作为服务质量的强化工具</li></ul></li><li>改进 SLO<ul><li>设置更低的响应时间、更改的吞吐量等</li></ul></li><li>保持一定的安全缓冲<ul><li>内部用的 SLO 要高于对外宣称的 SLO</li></ul></li><li>不要超额完成<ul><li>定期的 downtime 来使 SLO 不超额完成</li></ul></li></ul><p>设置SLO时的目标依赖于系统的不同状态(conditions)，根据不同状态设置不同的SLO，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总SLO &#x3D; service1.SLO1 * weight1 + service2.SLO2 * weight2 + …</span><br></pre></td></tr></table></figure><h3 id="SLO-的收益是什么？"><a href="#SLO-的收益是什么？" class="headerlink" title="SLO 的收益是什么？"></a>SLO 的收益是什么？</h3><ul><li>对于客户而言<ul><li>是可预期的服务质量，可以简化客户端的系统设计</li></ul></li><li>对于服务提供者而言 <ul><li>可预期的服务质量 </li><li>更好的取舍成本/收益 </li><li>更好的风险控制(当资源受限的时候)</li><li>故障时更快的反应，采取正确措施</li></ul></li></ul><h3 id="SLO-有哪些特性"><a href="#SLO-有哪些特性" class="headerlink" title="SLO 有哪些特性"></a>SLO 有哪些特性</h3><ul><li>SLO 是用 SLI 来描述的；</li><li>指定了服务所提供功能的一种期望状态；</li><li>SLO 是一种工具，可帮助您确定要优先处理的工程工作；</li><li>SLO 为服务的客户设置了目标可靠性级别。</li></ul><h3 id="如何保证能够达到目标呢？"><a href="#如何保证能够达到目标呢？" class="headerlink" title="如何保证能够达到目标呢？"></a>如何保证能够达到目标呢？</h3><blockquote><p>需要一个管理控制系统</p></blockquote><ul><li>监控/测量 SLIs</li><li>对比检测到的 SLIs 值是否达到目标</li><li>如果需要，修证目标或者修正系统以满足目标需要</li><li>实施目标的修改或者系统的修改</li></ul><p>该控制系统需要重复的执行以上动作，以形成一个标准的反馈环路，不断的衡量和改进 SLO 以及服务本身。</p>]]></content>
      
      
      <categories>
          
          <category> 可靠性 </category>
          
          <category> SLO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可靠性 </tag>
            
            <tag> SLO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cassandra 架构设计</title>
      <link href="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-004/"/>
      <url>/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-004/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Cassandra 架构设计 </p></blockquote><a id="more"></a><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><code>Apache Cassandra</code> 是一个大规模可扩展的分布式开源 <code>NoSQL</code> 数据库，完美适用于跨数据中心／云端的结构化数据、半结构化数据和非结构化数据，同时 <code>Cassandra</code> 具有灵活伸缩、高可用、错误容忍、可调的一致性等特性。</p><h1 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h1><ul><li>大数据量（集群模式）</li><li>大量的写、统计、分析</li><li>多数据中心</li><li>数据快速增长的应用</li></ul><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><table><thead><tr><th align="center">KeyWord</th><th align="center">Explain</th></tr></thead><tbody><tr><td align="center">Gossip</td><td align="center">点对点通信协议，用以Cassandra集群中节点间交换位置和状态信息。</td></tr><tr><td align="center">Partitioner</td><td align="center">决定如何在集群中的节点间分发数据，即在哪个节点放置数据的第一个replica。</td></tr><tr><td align="center">Replica placement strategy</td><td align="center">决定在哪些节点放置每行数据的其他replica。Cassandra在集群中的多个节点存储数据的多份拷贝(replicas)来确保可靠和容错。</td></tr><tr><td align="center">Snitch</td><td align="center">定义了复制策略用来放置replicas和路由请求所使用的拓扑信息</td></tr><tr><td align="center">Virtual nodes</td><td align="center">虚拟节点, 指定数据与物理节点的所属关系</td></tr><tr><td align="center">Token Ring</td><td align="center">令牌环</td></tr></tbody></table><h2 id="Data-Centers-and-Racks"><a href="#Data-Centers-and-Racks" class="headerlink" title="Data Centers and Racks"></a>Data Centers and Racks</h2><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-004/arch.png" class="" title="Arch"><h3 id="Rack"><a href="#Rack" class="headerlink" title="Rack"></a>Rack</h3><p>一个逻辑集合，有多个彼此临近 <code>node</code> 的组成。比如一个机架上的所有物理机器。</p><h3 id="Data-Center"><a href="#Data-Center" class="headerlink" title="Data Center"></a>Data Center</h3><p>有多个Rack组成的逻辑集合。建议将节点部署到多个数据中心。</p><h2 id="Gossip-and-Failure-Detection"><a href="#Gossip-and-Failure-Detection" class="headerlink" title="Gossip and Failure Detection"></a>Gossip and Failure Detection</h2><p><code>Gossip</code> 是一种 <code>p2p</code> 协议, 用于 <code>failure detection</code>, 跟踪其他节点的状态，每秒运行一次。<br>运用 <code>Phi Accrual Failure Detection</code> 实现 <code>failure detection</code><br>计算出一个结果 <code>level of suspicion</code>, 表示节点失败的可能性。<br>具有灵活性, 同时也避免了传统 <code>heartbeat</code> 的不可靠。可以应对只是短暂的网络拥塞。</p><div class="note info">            <p><code>Gossip</code> 介绍:<br><code>Gossip</code> 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><h3 id="Gossip-的优点"><a href="#Gossip-的优点" class="headerlink" title="Gossip 的优点"></a>Gossip 的优点</h3><ul><li><p>扩展性<br>网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</p></li><li><p>容错<br>网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</p></li><li><p>去中心化<br>Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</p></li><li><p>一致性收敛<br>Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</p></li><li><p>简单<br>Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。</p></li></ul><h3 id="Gossip-的缺陷"><a href="#Gossip-的缺陷" class="headerlink" title="Gossip 的缺陷"></a>Gossip 的缺陷</h3><p>分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：</p><ul><li><p>消息的延迟<br>由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。</p></li><li><p>消息冗余<br>Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。</p></li></ul>          </div><h2 id="Snitches"><a href="#Snitches" class="headerlink" title="Snitches"></a>Snitches</h2><p><code>snitch</code> 定义了集群中每个节点相对其他节点的邻近度, 以此来确定从哪个节点读取和写入。<br>一般采用手动定义的模式,在 <code>cassandra.yaml</code> 配置为 <code>endpoint_snitch</code>: <code>GossipingPropertyFileSnitch</code><br>同时在 <code>cassandra-rackdc.properties</code> 配置当前节点的 <code>dc</code> 和 <code>rack</code>，比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dc=dc1</span><br><span class="line">rack=rack2</span><br></pre></td></tr></table></figure><h2 id="Rings-and-Tokens"><a href="#Rings-and-Tokens" class="headerlink" title="Rings and Tokens"></a>Rings and Tokens</h2><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-004/rings.png" class="" title="Rings"><p>Cassandra 表示由集群管理的数据作为一个环。环中的每个节点被分配一个或多个由<code>token</code> 描述的数据范围，确定在环中的位置。</p><div class="note info">            <h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token 是用于标识每个分区的64位整数ID，范围是: 0 - 2^127<br>token 是一个0~2的127次方之间的一个整数，这也意味着理论上 <code>Cassandra</code> 可以支持 <code>2^127</code> 个节点）。之所以是 <code>2^127</code>，是因为 <code>MD5 HASH</code> 固定输出 128 位的数，去掉一位符号位，剩下127位。</p>          </div><p>通过 <code>hash算法</code> 计算 <code>partition key</code> 的 <code>hash值</code>，得到一个127位的数，然后将这个数与各节点的 <code>token</code> 比较来决定存储到哪个节点上。它根据以下规则进行节点选择：</p><ul><li>1.数据将存储到拥有最近的比key的hash值大的token的节点上；</li><li>2.若key的hash值比最大的token大，那将被存储到具有最小token的节点上。</li></ul><p>在配置文件 <code>cassandra.yaml</code> 里，有一个配置是 <code>initial_token</code>，这里就是配置该节点的 <code>token</code> 值。该值留空时，<code>Cassandra</code> 会自动给该节点分配一个<code>token</code> ，依据以下规则：</p><ul><li><p>1.若该节点已经被配置好准备加入集群，则 <code>Cassandra</code> 会根据集群现有的 <code>token</code> 来分配一个最平衡的 <code>token</code> 给该节点。很明显，分配一个 <code>token</code> 给新加入的节点，会让现有的某个节点减少一半的负载。若集群里有多个 <code>token</code> 都是一样平衡， 则它会选择一个可以分担目前存储了最多数据的节点的 <code>token</code> 。</p></li><li><p>2.若该节点还未准备好加入集群，则 <code>Cassandra</code> 会认为这个节点是引导节点，并分配一个固定值给它。所以若你分别单独配置两台节点，然后再尝试将它们集群，则会报告 <code>token</code> 重复。最好的方法应该是先单独配置第一台节点作为引导节点，然后后面的节点配置时应该也同时配置加入集群（后文说明），这样它们会自动获得一个平衡的 <code>token</code>。</p></li></ul><p>配置文件里的 <code>token</code> 仅在系统第一次启动时被使用，然后该值被写入 <code>system</code> 文件，以后系统启动将不再从配置文件读取 <code>token</code> 。因此若你发现两台节点的 <code>token</code> 重复，你无法通过改变配置文件里的 <code>token</code> 来改变节点的 <code>token</code> 。正确的修改方法是删除自定义 <code>token</code> 文件夹里的所有文件，重新启动服务。</p><p> <code>token</code> 会直接影响集群里节点所承受的负载，我们应该尽量保证每个节点所负责的 <code>token</code> 范围是平衡的。若你发现节点的负载不平衡，你可以手动改变它们的 <code>token</code> 来让它们平衡。先计算出每台节点的 <code>token</code> （平均分配），然后使用 <code>nodetool</code> 工具改变它。下面给出一个java里计算token的方法，参数是节点数。</p><h2 id="Virtual-Nodes"><a href="#Virtual-Nodes" class="headerlink" title="Virtual Nodes"></a>Virtual Nodes</h2><p>早期 <code>Cassandra</code> 版本给每个节点只分配了一个 <code>token</code> 范围，添加删除节点,需要手动重新配置 <code>token</code> 范围。一方面繁琐的操作，另一方面会导致大量的数据迁移。<br>在1.2版本介绍了 <code>virtual node</code> 的概念简称 <code>vnode</code> ,原先的 <code>token</code> 范围被缩减为多个更小的 <code>token</code> 范围。每个节点包含多个 <code>token</code> 范围。默认每个节点产生256个 <code>token</code> 范围（通过 <code>num_tokens</code> 调节），也就是256个 <code>vnode</code> 。在2.0以后默认开启。<br>在性能差的节点上, 可以适当减少 <code>num_tokens</code> 的值。<br><code>org.apache.cassandra.dht.tokenallocator.ReplicationAwareTokenAllocator</code>用于计算节点的token范围。</p><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-004/ringsvnode.png" class="" title="RingsAndVnode"><div class="note info">            <p>图解: 没有使用虚拟节点，Ring 环的 <code>tokens数量 = 集群的机器数量</code>。 比如上面一共有6个节点，所以 <code>token 数量 = 6</code>。<br>因为 <code>副本因子 = 3</code>，一条记录要在集群中的三个节点存在。简单地方式是计算 <code>rowkey的hash值</code>，落在环中的哪个 <code>token</code>上，第一份数据就在那个节点上, 剩余两个副本落在这个节点在 <code>token</code> 环上的后两个节点。<br>图中的 A,B,C,D,E,F 是 <code>key</code> 的范围，真实的值是 <code>hash环空间</code>，比如 0~2^32 区间分成10份，每一段是 2^32的 1/10 。<br><code>Note 1</code> 包含 A，F，E 表示 key 范围在 A，F，E 的数据会存储到 <code>Note 1</code> 上，以此类推。</p><h3 id="Rings-Without-Virtual-Nodes"><a href="#Rings-Without-Virtual-Nodes" class="headerlink" title="Rings Without Virtual Nodes"></a>Rings Without Virtual Nodes</h3><p>手工为集群中每个节点计算和分配一个 <code>token</code>。每个 <code>token</code> 决定了节点在环中的位置以及节点应当承担的一段连续的数据 <code>hash</code> 值的范围，每个节点分配了一个单独的 <code>token</code> 代表环中的一个位置，每个节点存储将<code>row key</code> 映射为 <code>hash</code> 值之后落在该节点应当承担的唯一的一段连续的 <code>hash</code> 值范围内的数据。每个节点也包含来自其他节点的 <code>row</code> 的副本。</p><h3 id="Rings-With-Virtual-Nodes"><a href="#Rings-With-Virtual-Nodes" class="headerlink" title="Rings With Virtual Nodes"></a>Rings With Virtual Nodes</h3><p>允许每个节点拥有多个较小的不连续的 <code>hash</code> 值范围，集群中的节点使用了虚拟节点，虚拟节点随机选择且不连续。数据的存放位置也由 <code>row key</code> 映射而得的hash值确定，但是是落在更小的分区范围内。</p><h3 id="The-Benefit-of-Using-Rings-with-virtual-nodes"><a href="#The-Benefit-of-Using-Rings-with-virtual-nodes" class="headerlink" title="The Benefit of Using Rings with virtual nodes"></a>The Benefit of Using Rings with virtual nodes</h3><ul><li>无需为每个节点计算、分配token</li><li>添加移除节点后无需重新平衡集群负载</li><li>减少大量的大量的数据迁移</li><li>重建故障节点更快</li></ul>          </div><h2 id="Partitioners"><a href="#Partitioners" class="headerlink" title="Partitioners"></a>Partitioners</h2><p><code>partitioners</code> 决定数据存放在哪个 <code>vnode</code> 上。它是一个 <code>hash</code> 函数，计算每行的  <code>partition key</code> 的 <code>hash</code> 值。<br>代码在 <code>org.apache.cassandra.dht</code> 包里,目前主要用 <code>Murmur3Partitioner</code><br><code>DHT</code>即为<code>distributed hash table</code>。</p><h2 id="Replication-Strategies"><a href="#Replication-Strategies" class="headerlink" title="Replication Strategies"></a>Replication Strategies</h2><p>第一份复制存在对应 <code>vnode</code> 中。其他复制的存放位置由 <code>replica strategy</code> (或叫<code>replica placement strategy</code>)决定。</p><p>主要有两种策略：</p><ul><li><p>SimpleStrategy<br>将副本放置在环上的连续节点处，从分区器指示的节点开始。</p></li><li><p>NetworkTopologyStrategy<br>允许为每个数据中心指定不同的复制因子。在数据中心内，它将副本分配给不同的 <code>rack</code>，以最大限度地提高可用性。</p></li></ul><h2 id="Consistency-Levels"><a href="#Consistency-Levels" class="headerlink" title="Consistency Levels"></a>Consistency Levels</h2><p>根据 <code>CAP理论</code>, 一致性(C)，可用性(A)和分区容忍性(P)不可兼得。<br><code>Cassandra</code> 通过设置读写时最少响应节点的数量，实现了可调的一致性。<br>可选的一致性级别：<code>ANY</code>, <code>ONE</code>, <code>TWO</code>, <code>THREE</code>, <code>QUORUM</code>, <code>ALL</code><br>其中 <code>QUORUM</code>, <code>ALL</code> 是强一致性。</p><p>强一致性公式：<code>R + W &gt; N</code> (R:读复制数， W:写复制数，N:复制因子)</p><h2 id="Queries-and-Coordinator-Nodes"><a href="#Queries-and-Coordinator-Nodes" class="headerlink" title="Queries and Coordinator Nodes"></a>Queries and Coordinator Nodes</h2><p>可以连接任一节点来执行读写操作<br>被连接的节点叫做 <code>Coordinator Nodes</code> ,需要处理读写一致性。比如：写到多个节点，从多个节点读取。</p><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-004/nodes.png" class="" title="Nodes"><h2 id="Memtables-SSTables-and-Commit-Log"><a href="#Memtables-SSTables-and-Commit-Log" class="headerlink" title="Memtables, SSTables, and Commit Log"></a>Memtables, SSTables, and Commit Log</h2><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-004/nodeinfo.png" class="" title="Node-Info"><h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>Caching 有三种 cache:</p><ul><li><p>key cache<br>缓存partiton keys到row index entries的映射，存在 jvm heap memory。</p></li><li><p>row cache<br>缓存常用的row, 存在 off-heap memory。</p></li><li><p>counter cache<br>提升counter性能，参见[Implementation of Counters]</p></li></ul><h2 id="Hinted-Hando"><a href="#Hinted-Hando" class="headerlink" title="Hinted Hando"></a>Hinted Hando</h2><p>一种写入高可用特性，当写入请求发给 <code>coordinator</code> 是，<code>replica节点</code> 可能因为种种原因不可用(网络、硬件等)，此时 <code>coordinator</code> 会临时保存写请求, 等到 <code>replica节点</code> 重新上线时再写入。</p><div class="note info">            <p><code>coordinator</code> 会临时保存写请求, 默认保留两个小时</p>          </div><h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><p>基本流程: 点对点分布式系统，集群中各节点平等，数据分布于集群中各节点，各节点间每秒交换一次信息。<br>每个节点的 <code>commit log</code> 提交日志捕获写操作来确保数据持久性。<br>数据先被写入 <code>MemTable</code> (内存中的数据结构)，待 <code>MemTable</code> 满后数据被写入 <code>SSTable</code> (硬盘的数据文件)。<br>所有的写内容被自动在集群中 <code>partition</code> 分区并 <code>replicate</code> 复制。</p><p>库表结构: <code>Cassandra</code> 数据库面向行。用户可连接至集群的任意节点，通过类似 SQL 的 <code>CQL</code> 查询数据。<br>集群中，一个应用一般包含一个keyspace，一个keyspace中包含多个表。</p><p>读写请求: 客户端连接到某一节点发起读或写请求时，该节点充当客户端应用与拥有相应数据的节点间的<br><code>coordinator</code> 协调者以根据集群配置确定环(ring)中的哪个节点应当获取这个请求。</p><img src="/2020/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-004/flow.png" class="" title="Flow">]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Cassandra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cassandra </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cassandra 监控方案</title>
      <link href="/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-003/"/>
      <url>/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-003/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Cassandra 数据库的监控方案 </p></blockquote><a id="more"></a><p>本文主要讲解 Cassandra 数据库的监控方案，以及部署过程，<br>主要由 Prometheus 进行数据采集、数据存储、数据处理，而 Grafana 则是用于监控页面展示。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Prometheus-简介"><a href="#Prometheus-简介" class="headerlink" title="Prometheus 简介"></a>Prometheus 简介</h2><p>Prometheus 是一个开源的监控框架，它通过不同的组件完成数据的采集，数据的存储，告警，其中 Prometheus server 只提供了数据存储（time series data），数据的处理（提供了丰富的查询语法[查询，统计，聚合等等]），数据则通过众多的插件（prometheus 称之为exporters）来暴露一个 http 服务的接口给 Prometheus 定时抓取， 告警则通过 Altermanger。</p><div class="note info">            <p>Prometheus 目前只能通过 PULL 的方式来获取数据 </p>          </div>## Grafana 简介Grafana 是一个开源的度量分析与可视化套件。纯 Javascript 开发的前端工具，通过访问库（如InfluxDB），展示自定义报表、显示图表等。大多使用在时序数据的监控方面，如同Kibana类似。Grafana的UI更加灵活，有丰富的插件，功能强大。Grafana支持许多不同的数据源。每个数据源都有一个特定的查询编辑器,该编辑器定制的特性和功能是公开的特定数据来源。<div class="note info">            <p> 官方支持以下数据源: </p><ul><li>Prometheus</li><li>Graphite </li><li>InfluxDB </li><li>OpenTSDB</li><li>MySQL </li><li>Elasticsearch </li><li>CloudWatch</li><li>KairosDB</li></ul>          </div><h1 id="监控系统部署"><a href="#监控系统部署" class="headerlink" title="监控系统部署"></a>监控系统部署</h1><div class="note info">            <p>项目路径 <code>/work/cassandra</code></p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/work/cassandra</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">bin conf data doc interface javadoc lib logs pylib tools</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>监控系统部署分为以下几个步骤： </p><ul><li>准备安装包</li><li>安装 <code>JMX exporter</code></li><li>安装 Prometheus</li><li>安装 Grafana</li><li>导入 Dashboard</li><li>效果展示</li></ul><h2 id="准备安装包"><a href="#准备安装包" class="headerlink" title="准备安装包"></a>准备安装包</h2><p><a href="https://github.com/prometheus/prometheus/releases/download/v2.17.1/prometheus-2.17.1.linux-amd64.tar.gz">Prometheus v2.17.1 下载</a></p><p><a href="https://github.com/grafana/grafana/archive/v6.7.2.zip">Grafana v6.7.2 下载</a></p><a href="/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-003/jmx_prometheus_javaagent-0.12.0.jar" title="jmx_prometheus_javaagent 下载">jmx_prometheus_javaagent 下载</a><h2 id="启用-JMX-exporter"><a href="#启用-JMX-exporter" class="headerlink" title="启用 JMX exporter"></a>启用 <code>JMX exporter</code></h2><div class="note info">            <p>启用 <code>JMX exporter</code> 需要在对 Cassandra 数据库集群各个节点操作。<br>服务器列表</p><ul><li>192.168.1.66</li><li>192.168.1.67</li><li>192.168.1.78</li></ul>          </div><ul><li><p>拷贝 <code>jmx_prometheus_javaagent-0.12.0.jar</code> 文件到 <code>${CASSANDRA_HOME}/lib</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cp jmx_prometheus_javaagent-0.12.0.jar $&#123;CASSANDRA_HOME&#125;/lib</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chown cassandra.cassandra $&#123;CASSANDRA_HOME&#125;/lib/jmx_prometheus_javaagent-0.12.0.jar</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure></li><li><p><code>${CASSANDRA_HOME}/conf</code> 新增 jmx.yaml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lowercaseOutputLabelNames:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">lowercaseOutputName:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">whitelistObjectNames:</span> <span class="string">["org.apache.cassandra.metrics:*"]</span></span><br><span class="line"><span class="comment"># ColumnFamily is an alias for Table metrics</span></span><br><span class="line"><span class="attr">blacklistObjectNames:</span> <span class="string">["org.apache.cassandra.metrics:type=ColumnFamily,*"]</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="comment"># Generic gauges with 0-2 labels</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">org.apache.cassandra.metrics&lt;type=(\S*)(?:,</span> <span class="string">((?!scope)\S*)=(\S*))?(?:,</span> <span class="string">scope=(\S*))?,</span> <span class="string">name=(\S*)&gt;&lt;&gt;Value</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cassandra_$1_$5</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">GAUGE</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="string">"$1"</span><span class="string">:</span> <span class="string">"$4"</span></span><br><span class="line">    <span class="string">"$2"</span><span class="string">:</span> <span class="string">"$3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Emulate Prometheus 'Summary' metrics for the exported 'Histogram's.</span></span><br><span class="line"><span class="comment"># TotalLatency is the sum of all latencies since server start</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">org.apache.cassandra.metrics&lt;type=(\S*)(?:,</span> <span class="string">((?!scope)\S*)=(\S*))?(?:,</span> <span class="string">scope=(\S*))?,</span> <span class="string">name=(.+)?(?:Total)(Latency)&gt;&lt;&gt;Count</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cassandra_$1_$5$6_seconds_sum</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">UNTYPED</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="string">"$1"</span><span class="string">:</span> <span class="string">"$4"</span></span><br><span class="line">    <span class="string">"$2"</span><span class="string">:</span> <span class="string">"$3"</span></span><br><span class="line">  <span class="comment"># Convert microseconds to seconds</span></span><br><span class="line">  <span class="attr">valueFactor:</span> <span class="number">0.000001</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">org.apache.cassandra.metrics&lt;type=(\S*)(?:,</span> <span class="string">((?!scope)\S*)=(\S*))?(?:,</span> <span class="string">scope=(\S*))?,</span> <span class="string">name=((?:.+)?(?:Latency))&gt;&lt;&gt;Count</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cassandra_$1_$5_seconds_count</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">UNTYPED</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="string">"$1"</span><span class="string">:</span> <span class="string">"$4"</span></span><br><span class="line">    <span class="string">"$2"</span><span class="string">:</span> <span class="string">"$3"</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">org.apache.cassandra.metrics&lt;type=(\S*)(?:,</span> <span class="string">((?!scope)\S*)=(\S*))?(?:,</span> <span class="string">scope=(\S*))?,</span> <span class="string">name=(.+)&gt;&lt;&gt;Count</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cassandra_$1_$5_count</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">UNTYPED</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="string">"$1"</span><span class="string">:</span> <span class="string">"$4"</span></span><br><span class="line">    <span class="string">"$2"</span><span class="string">:</span> <span class="string">"$3"</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">org.apache.cassandra.metrics&lt;type=(\S*)(?:,</span> <span class="string">((?!scope)\S*)=(\S*))?(?:,</span> <span class="string">scope=(\S*))?,</span> <span class="string">name=((?:.+)?(?:Latency))&gt;&lt;&gt;(\d+)thPercentile</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cassandra_$1_$5_seconds</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">GAUGE</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="string">"$1"</span><span class="string">:</span> <span class="string">"$4"</span></span><br><span class="line">    <span class="string">"$2"</span><span class="string">:</span> <span class="string">"$3"</span></span><br><span class="line">    <span class="attr">quantile:</span> <span class="string">"0.$6"</span></span><br><span class="line">  <span class="comment"># Convert microseconds to seconds</span></span><br><span class="line">  <span class="attr">valueFactor:</span> <span class="number">0.000001</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">pattern:</span> <span class="string">org.apache.cassandra.metrics&lt;type=(\S*)(?:,</span> <span class="string">((?!scope)\S*)=(\S*))?(?:,</span> <span class="string">scope=(\S*))?,</span> <span class="string">name=(.+)&gt;&lt;&gt;(\d+)thPercentile</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cassandra_$1_$5</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">GAUGE</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="string">"$1"</span><span class="string">:</span> <span class="string">"$4"</span></span><br><span class="line">    <span class="string">"$2"</span><span class="string">:</span> <span class="string">"$3"</span></span><br><span class="line">    <span class="attr">quantile:</span> <span class="string">"0.$6"</span></span><br></pre></td></tr></table></figure></li><li><p><code>${CASSANDRA_HOME}/conf/cassandra-env.sh</code>增加启动参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM_OPTS=<span class="string">"<span class="variable">$JVM_OPTS</span> -javaagent:<span class="variable">$&#123;CASSANDRA_HOME&#125;</span>/lib/jmx_prometheus_javaagent-0.12.0.jar=7070:<span class="variable">$&#123;CASSANDRA_HOME&#125;</span>/conf/jmx.yaml"</span></span><br></pre></td></tr></table></figure><p>如下图所示:</p><img src="/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-003/photo001.png" class="" title="图片"></li><li><p>重启 Cassandra 数据库服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># su cassandra</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$&#123;CASSANDRA_HOME&#125;</span></span><br><span class="line">$ ./stop.sh</span><br><span class="line">$ ./start.sh</span><br></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl 192.168.1.78:7070 &gt; collection.txt</span></span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  826k  100  826k    0     0   632k      0  0:00:01  0:00:01 --:--:--  632k</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装-Prometheus"><a href="#安装-Prometheus" class="headerlink" title="安装 Prometheus"></a>安装 Prometheus</h2><div class="note info">            <p>项目路径: <code>/work/prometheus</code><br>服务地址: <code>192.168.1.15:9090</code></p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/work/prometheus</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">bin conf <span class="built_in">log</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li><p>新建 conf/prometheus.yml 文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">prometheus.yml</span> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span> <span class="comment"># By default, scrape targets every 15 seconds.</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span> <span class="comment"># By default, scrape targets every 15 seconds.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">'test-cluster'</span></span><br><span class="line">    <span class="attr">monitor:</span> <span class="string">"prometheus"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line"> <span class="attr">alertmanagers:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">'192.168.1.234:9093'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'cassandra'</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line">    <span class="comment">#honor_labels: true # don't overwrite job &amp; instance labels</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'192.168.1.66:7070'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'192.168.1.67:7070'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'192.168.1.78:7070'</span></span><br></pre></td></tr></table></figure></li><li><p>新建启动脚本 <code>/work/prometheus/run_prometheus.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">ulimit</span> -n 1000000</span><br><span class="line"></span><br><span class="line">DEPLOY_DIR=/work/prometheus</span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$&#123;DEPLOY_DIR&#125;</span>"</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># WARNING: This file was auto-generated. Do not edit!</span></span><br><span class="line"><span class="comment">#          All your edit might be overwritten!</span></span><br><span class="line"><span class="built_in">exec</span> &gt; &gt;(tee -i -a <span class="string">"/work/prometheus/log/prometheus.log"</span>)</span><br><span class="line"><span class="built_in">exec</span> 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> bin/prometheus \</span><br><span class="line">    --config.file=<span class="string">"/work/prometheus/conf/prometheus.yml"</span> \</span><br><span class="line">    --web.listen-address=<span class="string">":9090"</span> \</span><br><span class="line">    --web.external-url=<span class="string">"http://192.168.1.15:9090/"</span> \</span><br><span class="line">    --web.enable-admin-api \</span><br><span class="line">    --log.level=<span class="string">"info"</span> \</span><br><span class="line">    --storage.tsdb.path=<span class="string">"/work/prometheus</span></span><br></pre></td></tr></table></figure></li><li><p>启动 prometheus 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh run_prometheus.sh</span><br></pre></td></tr></table></figure><h2 id="安装-Grafana"><a href="#安装-Grafana" class="headerlink" title="安装 Grafana"></a>安装 Grafana</h2><div class="note info">            <p>项目路径: <code>/work/gafana</code><br>服务地址: <code>192.168.1.15:3000</code></p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/work/gafana</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">bin conf <span class="built_in">log</span> opt </span><br><span class="line"><span class="comment"># 注意: opt/grafana 是 Grafana 服务路径</span></span><br></pre></td></tr></table></figure></li><li><p>编辑 <code>/work/gafana/conf/grafana.ini</code> 配置文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[paths]</span></span><br><span class="line"><span class="attr">data</span> = /work/gafana/data.grafana</span><br><span class="line"><span class="attr">logs</span> = /work/gafana/log</span><br><span class="line"><span class="attr">plugins</span> = /work/gafana/opt/grafana/plugins</span><br><span class="line"><span class="section">[server]</span></span><br><span class="line"><span class="attr">http_port</span> = <span class="number">3000</span></span><br><span class="line"><span class="attr">domain</span> = <span class="number">192.168</span>.<span class="number">1.15</span></span><br><span class="line"><span class="attr">check_for_updates</span> = <span class="literal">true</span></span><br><span class="line"><span class="section">[security]</span></span><br><span class="line"><span class="attr">admin_user</span> = admin</span><br><span class="line"><span class="attr">admin_password</span> = admin</span><br><span class="line"><span class="section">[log.file]</span></span><br><span class="line"><span class="attr">level</span> = info</span><br><span class="line"><span class="attr">format</span> = text</span><br><span class="line"><span class="section">[dashboards.json]</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">path</span> = /work/grafana/opt/grafana/dashboards</span><br></pre></td></tr></table></figure></li><li><p>新建启动脚本 <code>/work/prometheus/run_grafana.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">ulimit</span> -n 1000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># WARNING: This file was auto-generated. Do not edit!</span></span><br><span class="line"><span class="comment">#          All your edit might be overwritten!</span></span><br><span class="line">DEPLOY_DIR=/work/grafana</span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$&#123;DEPLOY_DIR&#125;</span>"</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">LANG=en_US.UTF-8 \</span><br><span class="line"><span class="built_in">exec</span> opt/grafana/bin/grafana-server \</span><br><span class="line">        --homepath=<span class="string">"/work/grafana/opt/grafana"</span> \</span><br><span class="line">        --config=<span class="string">"/work/grafana/opt/grafana/conf/grafana.ini"</span></span><br></pre></td></tr></table></figure></li><li><p>启动 Grafana</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run_grafana.sh</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="导入-Dashboard"><a href="#导入-Dashboard" class="headerlink" title="导入 Dashboard"></a>导入 Dashboard</h2><a href="/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-003/Cassandra-DashBoard.zip" title="Cassandra-DashBoard 下载">Cassandra-DashBoard 下载</a><img src="/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-003/photo002.png" class="" title="图片2"><img src="/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-003/photo003.png" class="" title="图片3"><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><img src="/2020/04/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-003/photo004.png" class="" title="图片4">]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Cassandra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cassandra </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Prometheus </tag>
            
            <tag> Grafana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cassandra 集群部署</title>
      <link href="/2020/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-002/"/>
      <url>/2020/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-002/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>如何部署一套线上 Cassandra 集群</p></blockquote><a id="more"></a><p>本文主要讲解 Cassandra 3.11.6 集群的安装部署过程， 分为以下几个步骤： </p><ul><li>准备安装包</li><li>基础环境安装</li><li>配置集群节点</li><li>集群部署</li><li><code>nodetool</code> 工具使用</li></ul><h1 id="准备安装包"><a href="#准备安装包" class="headerlink" title="准备安装包"></a>准备安装包</h1><ul><li><a href="https://www.oracle.com/cn/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">JDK1.8 下载</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/cassandra/3.11.6/apache-cassandra-3.11.6-bin.tar.gz" target="_blank" rel="noopener">Cassandra 3.11.6下载</a></li><li>python 环境(python2.7及以上, 建议 python 3.7)</li></ul><h1 id="基础环境安装"><a href="#基础环境安装" class="headerlink" title="基础环境安装"></a>基础环境安装</h1><h2 id="项目路径-示例地址-work-cassandra"><a href="#项目路径-示例地址-work-cassandra" class="headerlink" title="项目路径 (示例地址: /work/cassandra )"></a>项目路径 (示例地址: /work/cassandra )</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir /work/cassandra</span></span><br></pre></td></tr></table></figure><h2 id="安装-JDK1-8-以-jdk1-8-0-191-为例"><a href="#安装-JDK1-8-以-jdk1-8-0-191-为例" class="headerlink" title="安装 JDK1.8 (以 jdk1.8.0_191 为例)"></a>安装 <code>JDK1.8</code> (以 jdk1.8.0_191 为例)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo $&#123;JAVA_HOME&#125;</span></span><br><span class="line">/opt/soft/jdk/jdk1.8.0_191</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">"1.8.0_191"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)</span><br></pre></td></tr></table></figure><h2 id="检查-python-环境"><a href="#检查-python-环境" class="headerlink" title="检查 python 环境"></a>检查 python 环境</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python --version</span></span><br><span class="line">Python <span class="number">2.7</span><span class="number">.14</span></span><br></pre></td></tr></table></figure><h2 id="解压缩-Cassandra-安装包"><a href="#解压缩-Cassandra-安装包" class="headerlink" title="解压缩 Cassandra 安装包"></a>解压缩 Cassandra 安装包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tar xf apache-cassandra-3.11.1-bin.tar.gz</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># mv apache-cassandra-3.11.6/* /work/cassandra</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/work/cassandra</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">bin conf doc interface javadoc lib pylib tools</span><br></pre></td></tr></table></figure><h1 id="配置集群节点"><a href="#配置集群节点" class="headerlink" title="配置集群节点"></a>配置集群节点</h1><h2 id="Cassandra-基础环境配置"><a href="#Cassandra-基础环境配置" class="headerlink" title="Cassandra 基础环境配置"></a>Cassandra 基础环境配置</h2><h3 id="添加-cassandra-用户"><a href="#添加-cassandra-用户" class="headerlink" title="添加 cassandra 用户"></a>添加 cassandra 用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解除账号锁定</span></span><br><span class="line"><span class="comment"># chattr -i /etc/passwd;chattr -i /etc/shadow;chattr -i /etc/group;chattr -i /etc/gshadow</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># useradd cassandra</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># id cassandra</span></span><br><span class="line">uid=1008(cassandra) gid=1008(cassandra) groups=1008(cassandra)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 添加账号锁定</span></span><br><span class="line"><span class="comment"># chattr +i /etc/passwd;chattr +i /etc/shadow;chattr +i /etc/group;chattr +i /etc/gshadow</span></span><br></pre></td></tr></table></figure><h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim /etc/profile.d/cassandra.sh</span></span><br><span class="line"><span class="comment"># 写入以下内容保存</span></span><br><span class="line"><span class="built_in">export</span> CASSANDRA_HOME=/work/cassandra</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$CASSANDRA_HOME</span>/bin</span><br><span class="line"><span class="comment"># . /etc/profile</span></span><br></pre></td></tr></table></figure><h3 id="创建-Cassandra-数据目录、日志目录"><a href="#创建-Cassandra-数据目录、日志目录" class="headerlink" title="创建 Cassandra 数据目录、日志目录"></a>创建 Cassandra 数据目录、日志目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /work/cassandra</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 创建 数据目录、日志目录</span></span><br><span class="line"><span class="comment"># mkdir data logs</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">bin conf data doc interface javadoc lib logs pylib tools</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 数据库目录权限</span></span><br><span class="line"><span class="comment"># chown -R cassandra.cassandra .</span></span><br></pre></td></tr></table></figure><h3 id="创建启停脚本"><a href="#创建启停脚本" class="headerlink" title="创建启停脚本"></a>创建启停脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/work/cassandra</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cat start.sh </span></span><br><span class="line">nohup bin/cassandra &gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cat bin/stop-server</span></span><br><span class="line">user=`whoami`</span><br><span class="line">pgrep -u <span class="variable">$user</span> -f cassandra | xargs <span class="built_in">kill</span> -15</span><br><span class="line"><span class="comment"># cat stop.sh </span></span><br><span class="line">bin/stop-server</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>记得要将数据库目录归属权限授予用户 cassandra  </p>          </div><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li>cassandra.yaml<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">cluster_name: <span class="string">'Test Cluster'</span></span><br><span class="line">num_tokens: 256</span><br><span class="line">hinted_handoff_enabled: <span class="literal">true</span></span><br><span class="line">hinted_handoff_throttle_in_kb: 1024</span><br><span class="line">max_hints_delivery_threads: 2</span><br><span class="line">hints_directory: /work/cassandra/data/hints</span><br><span class="line">hints_flush_period_in_ms: 10000</span><br><span class="line">max_hints_file_size_in_mb: 128</span><br><span class="line">batchlog_replay_throttle_in_kb: 1024</span><br><span class="line">authenticator: AllowAllAuthenticator</span><br><span class="line">authorizer: AllowAllAuthorizer</span><br><span class="line">role_manager: CassandraRoleManager</span><br><span class="line">roles_validity_in_ms: 2000</span><br><span class="line">permissions_validity_in_ms: 2000</span><br><span class="line">credentials_validity_in_ms: 2000</span><br><span class="line">partitioner: org.apache.cassandra.dht.Murmur3Partitioner</span><br><span class="line">data_file_directories: </span><br><span class="line">    - /work/cassandra/data</span><br><span class="line">commitlog_directory: /work/cassandra/data/commitlog</span><br><span class="line">cdc_enabled: <span class="literal">false</span></span><br><span class="line">disk_failure_policy: stop</span><br><span class="line">commit_failure_policy: stop</span><br><span class="line">prepared_statements_cache_size_mb:</span><br><span class="line">thrift_prepared_statements_cache_size_mb:</span><br><span class="line">key_cache_size_in_mb:</span><br><span class="line">key_cache_save_period: 14400</span><br><span class="line">row_cache_size_in_mb: 0</span><br><span class="line">row_cache_save_period: 0</span><br><span class="line">counter_cache_size_in_mb:</span><br><span class="line">counter_cache_save_period: 7200</span><br><span class="line">saved_caches_directory: /work/cassandra/data/saved_caches</span><br><span class="line">commitlog_sync: periodic</span><br><span class="line">commitlog_sync_period_in_ms: 10000</span><br><span class="line">commitlog_segment_size_in_mb: 32</span><br><span class="line">seed_provider:</span><br><span class="line">  - class_name: org.apache.cassandra.locator.SimpleSeedProvider</span><br><span class="line">    parameters:</span><br><span class="line">      - seeds: <span class="string">"192.168.1.78,192.168.1.66,192.168.1.67"</span></span><br><span class="line">concurrent_reads: 32</span><br><span class="line">concurrent_writes: 32</span><br><span class="line">concurrent_counter_writes: 32</span><br><span class="line">concurrent_materialized_view_writes: 32</span><br><span class="line">memtable_allocation_type: heap_buffers</span><br><span class="line">index_summary_capacity_in_mb:</span><br><span class="line">index_summary_resize_interval_in_minutes: 60</span><br><span class="line">trickle_fsync: <span class="literal">false</span></span><br><span class="line">trickle_fsync_interval_in_kb: 10240</span><br><span class="line">storage_port: 7000</span><br><span class="line">ssl_storage_port: 7001</span><br><span class="line">listen_address: 192.168.1.78 </span><br><span class="line">start_native_transport: <span class="literal">true</span></span><br><span class="line">native_transport_port: 9042</span><br><span class="line">start_rpc: <span class="literal">true</span></span><br><span class="line">rpc_address: 192.168.1.78 </span><br><span class="line">rpc_port: 9160</span><br><span class="line">rpc_keepalive: <span class="literal">true</span></span><br><span class="line">rpc_server_type: sync</span><br><span class="line">auto_snapshot: <span class="literal">true</span></span><br><span class="line">column_index_size_in_kb: 64</span><br><span class="line">column_index_cache_size_in_kb: 2</span><br><span class="line">compaction_throughput_mb_per_sec: 16</span><br><span class="line">sstable_preemptive_open_interval_in_mb: 50</span><br><span class="line">read_request_timeout_in_ms: 5000</span><br><span class="line">range_request_timeout_in_ms: 10000</span><br><span class="line">write_request_timeout_in_ms: 2000</span><br><span class="line">counter_write_request_timeout_in_ms: 5000</span><br><span class="line">cas_contention_timeout_in_ms: 1000</span><br><span class="line">truncate_request_timeout_in_ms: 60000</span><br><span class="line">request_timeout_in_ms: 10000</span><br><span class="line">slow_query_log_timeout_in_ms: 500</span><br><span class="line">cross_node_timeout: <span class="literal">false</span></span><br><span class="line">endpoint_snitch: SimpleSnitch</span><br><span class="line">dynamic_snitch_update_interval_in_ms: 100 </span><br><span class="line">dynamic_snitch_reset_interval_in_ms: 600000</span><br><span class="line">dynamic_snitch_badness_threshold: 0.1</span><br><span class="line">request_scheduler: org.apache.cassandra.scheduler.NoScheduler</span><br><span class="line">internode_compression: dc</span><br><span class="line">inter_dc_tcp_nodelay: <span class="literal">false</span></span><br><span class="line">tracetype_query_ttl: 86400</span><br><span class="line">tracetype_repair_ttl: 604800</span><br><span class="line">enable_user_defined_functions: <span class="literal">false</span></span><br><span class="line">enable_scripted_user_defined_functions: <span class="literal">false</span></span><br><span class="line">windows_timer_interval: 1</span><br><span class="line">gc_warn_threshold_in_ms: 1000</span><br><span class="line">back_pressure_enabled: <span class="literal">false</span></span><br><span class="line">back_pressure_strategy:</span><br><span class="line">    - class_name: org.apache.cassandra.net.RateBasedBackPressure</span><br><span class="line">      parameters:</span><br><span class="line">        - high_ratio: 0.90</span><br><span class="line">          factor: 5</span><br><span class="line">          flow: FAST</span><br><span class="line">enable_materialized_views: <span class="literal">true</span></span><br><span class="line">enable_sasi_indexes: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>jvm.options 限制进程最大内存，避免 OOM<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms16G</span><br><span class="line">-Xmx16G</span><br><span class="line">-Xmn4G</span><br></pre></td></tr></table></figure><h1 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h1></li></ul><p>服务器列表</p><ul><li>192.168.1.66</li><li>192.168.1.67</li><li>192.168.1.78</li></ul><h2 id="启动步骤"><a href="#启动步骤" class="headerlink" title="启动步骤"></a>启动步骤</h2><ul><li>在各个节点上创建 cassandra 用户，安装 JDK、Cassandra 数据库、Python环境</li><li>配置统一集群的名字</li><li>为每个节点分配一个IP</li><li>确定种子节点，不需要配置全部节点</li><li>如果是多数据中心，为每个数据中心和机架确定命名约定</li></ul><h2 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/work/cassandra</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 切换到 cassandra 用户</span></span><br><span class="line"><span class="comment"># su cassandra</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">$ ./start.sh</span><br></pre></td></tr></table></figure><h2 id="如需关停节点"><a href="#如需关停节点" class="headerlink" title="如需关停节点"></a>如需关停节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd</span></span><br><span class="line">/work/cassandra</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 切换到 cassandra 用户</span></span><br><span class="line"><span class="comment"># su cassandra</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">$ ./stop.sh</span><br></pre></td></tr></table></figure><h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nodetool status</span></span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address       Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  192.168.1.66  3.97 GiB   256          32.3%             641c928e-873d-4d6d-9c1e-a473206193f4  rack1</span><br><span class="line">UN  192.168.1.67  3.99 GiB   256          32.6%             ca4b1c70-1077-4963-89ed-583307cd2b17  rack1</span><br><span class="line">UN  192.168.1.78  4.52 GiB   256          35.1%             0618f9f6-ac66-43cb-bf39-edd70519d409  rack1</span><br></pre></td></tr></table></figure><h1 id="nodetool-工具使用"><a href="#nodetool-工具使用" class="headerlink" title="nodetool 工具使用"></a><code>nodetool</code> 工具使用</h1><ul><li><p>nodetool 工具使用帮助</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出nodetool所有可用的命令</span></span><br><span class="line">$ nodetool <span class="built_in">help</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出指定command 的帮助内容</span></span><br><span class="line">$ nodetool <span class="built_in">help</span> <span class="built_in">command</span>-name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：查看status 命令的详细帮助内容</span></span><br><span class="line">$ nodetool <span class="built_in">help</span> status</span><br></pre></td></tr></table></figure></li><li><p>查看集群运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nodetool status</span><br></pre></td></tr></table></figure></li><li><p>移除某个废弃节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令模板</span></span><br><span class="line">$ nodetool &lt;options&gt; removenode -- &lt;status&gt; | &lt;force&gt; | &lt;ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用实例</span></span><br><span class="line"><span class="comment"># 移除Host ID为 641c928e-873d-4d6d-9c1e-a473206193f4 的节点</span></span><br><span class="line">$ nodetool removenode 641c928e-873d-4d6d-9c1e-a473206193f4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看节点删除状态</span></span><br><span class="line">$ nodetool removenode status</span><br></pre></td></tr></table></figure></li><li><p>参看某个节点负载，内存使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nodetool info</span><br></pre></td></tr></table></figure></li><li><p>查看各个CF的详细统计信息，包括读写次数、响应时间、memtable信息等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nodetool cfstats</span><br></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nodetool <span class="built_in">help</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Cassandra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cassandra </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cassandra 简介</title>
      <link href="/2020/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-001/"/>
      <url>/2020/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-001/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Apache Cassandra 是一个大规模可扩展的分布式开源NoSQL数据库 </p></blockquote><a id="more"></a><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Apache Cassandra 是一个大规模可扩展的分布式开源NoSQL数据库，完美适用于跨数据中心／云端的结构化数据、半结构化数据和非结构化数据，同时，Cassandra 高可用、线性可扩展、高性能、无单点。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>Scalable，线性可扩展</li><li>Fault-Tolerant，且没有单点（peer-to-peer）</li><li>Column-Oriented Database &amp; Partitioned Row Store Database</li><li>Distribution Design 基于 Amazon 的 Dynamo</li><li>Data Model 基于 Google 的 Bigtable</li><li>灵活的数据存储，支持结构化、半结构化、非结构化数据</li><li>支持事务</li><li>写性能好</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><blockquote><p>Cassandra 是专注于可用性和分区容错性的解决方案的最佳选择。</p></blockquote><p>CAP 代表“一致性、可用性和分区容错性”。CAP 定理由 Eric Brewer 在 2000 年首次提出，该定理表明，在任何共享数据系统中，最多只能获得这些属性中的两个。所以您必须选择两个属性；不能选择所有属性。我将大体介绍一下该定理，要获取更多信息，请参阅下面的“相关主题”。</p><p>CAP 定理与 Cassandra 相关，所以理解该定理很重要，因为它可能帮助您判断 Cassandra 是不是您的 NoSQL 数据库解决方案的最佳选择。在任何情况下，都应该首先考虑您的解决方案在一致性和可用性方面的约束，这很有帮助。</p><p>依据 CAP 定理，对于任何分布式系统，都必须为它选择两种最重要的保证（参见图 1）。您可以拥有 Cassandra 中的所有 3 种保证，但不能同时拥有它们。因此，在您想要获得一个不会宕机且高度可用的数据库，而且不想遭遇偶然的硬件故障时，Cassandra 是专注于可用性和分区容错性的解决方案的最佳选择。</p><p>这与传统关系数据库管理系统 (RDBMS)（比如 MySQL、DB2®、Oracle 和 Sybase）的 ACID（原子性、一致性、隔离性、耐久性）属性相反。我并没有暗示在 Cassandra 中没有原子操作，以及 Cassandra 数据不是隔离的或耐久的。我的意思是说，这些不是 Cassandra 的主要关注点。该数据库天生就是分布式的，能随着数据和应用程序事务的增长而轻松扩展。</p><img src="/2020/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-001/figure1.png" class="" title="[1] CAP 定理的保证与 Cassandra"><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>Cassandra 实质上是一个分布式数据库。这意味着它被设计为在计算机节点网络中以服务器形式运行，不同部分在不同机器上运行，没有任何特定的硬件或软件需要管理或协调。所有节点的协调和数据分布都是在它们自己的架构内完成的。 Cassandra 网络之所以比其他常见关系数据库系统更容易水平扩展且更便宜，这就是原因之一。</p><p>典型的 Cassandra 网络拓扑结构包含一个节点集群（也称为 Cassandra 环），每个节点在不同物理服务器上的不同网络地址中运行。</p><img src="/2020/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-001/figure2.png" class="" title="[1] 不同网络主机中的节点的 Cassandra 集群"><p>此特性提高了网络在节点发生故障时的可用性。每个节点都可以协调客户端的请求，而不需要主节点，因此没有单点故障。您还能设置不同的配置战略来让数据知道不同节点的位置，从而进一步提高系统可用性。</p><blockquote><p>下图包含 8 个节点的 Cassandra 集群收到一个客户端连接，<br>该连接将数据写入一个配置了复制系数 3 的键空间中。</p></blockquote><img src="/2020/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-001/figure3.png" class="" title="[1] 不同网络主机中的节点的 Cassandra 集群"><p>所有数据都依据一个哈希算法均匀分布在 Cassandra 环（节点）中，以创建所需的副本（也称为复制品）数量。复制系数是集群配置的一个重要方面。该系数是通过一个键空间或模式配置来定义的。</p><p>关于集群数据、拓扑结构、节点可用性和性能的所有信息都通过 gossip 协议（一种对等协议）在节点之间进行交换。可使用此信息向客户端发出关于哪个节点最适合在给定时间写入或读取任何数据的连接建议。</p><p>Cassandra 客户端可通过两种协议与服务器进行通信：CQL 二进制协议或一种称为 thrift 的 RPC 协议。CQL 二进制协议是一种较新的协议，该协议优先于 thrift。Cassandra 查询语言 (CQL) 是一种类似于 SQL 的语言，Cassandra 使用它创建处理其模式结构和数据（DDL 和 DML）的命令。</p><h2 id="CQL"><a href="#CQL" class="headerlink" title="CQL"></a>CQL</h2><p>CQL (Cassandra Query Language)是用于 Cassandra 的查询语言，可类比用于关系型数据库的 SQL ，注意，虽然 CQL 和 SQL 看起来比较相似，但二者内部原理完全不同。</p><h2 id="基本数据结构和建模"><a href="#基本数据结构和建模" class="headerlink" title="基本数据结构和建模"></a>基本数据结构和建模</h2><p>Cassandra 的一个重要且有时很难处理的方面是它的数据建模方法。首先，您需要了解如何在其架构内组织它的数据，然后如何建模您的应用程序的数据结构，以便获得其最高性能。</p><p>在 Cassandra 中，所有数据都通过一个主键（或行键）按分区进行组织，这使您能访问所有列或键/值对集合，如下图所示。</p><blockquote><p>Cassandra 数据结构分区</p></blockquote><img src="/2020/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93/Cassandra/Cassandra-001/figure4.png" class="" title="[4] 不同网络主机中的节点的 Cassandra 集群"><p>对于每一个 column family，不要想象成关系型数据库的表，而要想像成一个多层嵌套的排序散列表（Nested sorted map）。这样能更好地理解和设计 Cassandra 的数据模型。</p><p>散列表可用提供高效的键值查找，排序的散列表可提供高效的范围查找，在  Cassandra 里，我们可以使用 primary key 和 column key 做高效的键值查询和范围查询，而且，在 Cassandra 中，列的名称可以直接包含数据，也就是说，有的列可以只有列名没有列值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;RowKey, SortedMap&lt;ColumnKey, ColumnValue&gt;&gt;</span><br></pre></td></tr></table></figure><p>Cassandra 是一个 column-oriented database，也就是说，不用像关系型数据库一样事先定义好列，在 Cassandra 中，不同行的列可以不一样。</p><p>在 Cassandra 中，数据模型由 keyspaces、column families、primary key 和 columns 组成，对比关系型数据库，如下表：</p><table><thead><tr><th align="center">关系型数据库</th><th align="center">Cassandra</th></tr></thead><tbody><tr><td align="center">Database</td><td align="center">Keyspace</td></tr><tr><td align="center">Table</td><td align="center">CF(column family)</td></tr><tr><td align="center">Primary Key</td><td align="center">Primary Key</td></tr><tr><td align="center">Column Name</td><td align="center">Key / Column Name</td></tr><tr><td align="center">Column Value</td><td align="center">Column Value</td></tr></tbody></table><p>在 Cassandra 中，Primary Key 包括 partition key 和 cluster key 两部分，其中 cluster key 可选，partition key 确定数据行分发到哪个 node，cluster key 用于 node 内部数据排序。</p><p>当您在 Cassandra 中创建一个表时，您使用了一条与以下命令类似的 CQL 命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> movie_catalog (<span class="keyword">category</span> <span class="built_in">text</span>, <span class="keyword">year</span> <span class="built_in">int</span>, title <span class="built_in">text</span>, </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">category</span>));</span><br></pre></td></tr></table></figure><p>第一列被隐式地视为 movie_catalog 表的分区键。没有集群键。但是，假设您在主键中添加了 year 列，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> movie_catalog (<span class="keyword">category</span> <span class="built_in">text</span>, <span class="keyword">year</span> <span class="built_in">int</span>, title <span class="built_in">text</span>, </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">category</span>,<span class="keyword">year</span>))</span><br></pre></td></tr></table></figure><p>现在，category 继续作为分区键，而 year 列是集群键。两列都是主键的一部分。</p><div class="note info">            <p>所有 Cassandra 表都必须有一个主键来确定数据位于集群中的哪个节点。该键至少要包含一个分区键。如上所示，用于定位节点（分区）中的数据的集群键也可以是主键的一部分。 </p>          </div><p>所以对于建模问题，必须小心选择分区键，使 Cassandra 能高效地将数据分布到节点中。将所有应用程序数据（行）放在一个分区中不是一个好主意。出于同样的原因，您还可以拥有许多分区。因此，您需要在对数据进行分组时找到一个很好的平衡点，以满足您的应用程序需求。</p><p>在 Cassandra 中建模的最常用技术称为基于查询的建模。此方法需要您考虑应用程序用户发出的查询。然后，您可以根据这些查询对表进行建模。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Cassandra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cassandra </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M3O - 运行时工具 micro api</title>
      <link href="/2020/04/12/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-006/"/>
      <url>/2020/04/12/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-006/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>M3O - 运行时工具 micro api </p></blockquote><a id="more"></a><blockquote><p><code>micro api</code> 就是 api 网关</p></blockquote><p>API 网关模式为服务提供了一个单一的公共入口。通过服务发现，<code>micro api</code> 以http 方式，将请求动态路由到具体的后台服务接口。我们以下简称 <code>API网关</code>。</p><img src="/2020/04/12/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-006/api.png" class=""><p>这种服务方式，将简化下游服务调用方式，极大的降低了使用难度。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>API网关</code> 基于 <code>go-micro</code> 开发，所以它默认具备<code>服务发现</code>、<code>负载均衡</code>、<code>编码及RPC通信的能力</code>，故而，<code>API网关</code> 也是 <code>go-micro</code> 体系中的一个微服务，所以它自身也是可插拔的。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/micro/micro</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认的端口是8080, 如果不指定注册中心，默认 MICRO_REGISTRY 为 mdns</span></span><br><span class="line">micro api</span><br></pre></td></tr></table></figure><h2 id="使用ACME协议"><a href="#使用ACME协议" class="headerlink" title="使用ACME协议"></a>使用ACME协议</h2><p>ACME（ Automatic Certificate Management Environment）是由 Let’s Encrypt制定的安全协议。</p><h3 id="ACME-资料"><a href="#ACME-资料" class="headerlink" title="ACME 资料"></a>ACME 资料</h3><ul><li><a href="https://letsencrypt.org/zh-cn/docs/" target="_blank" rel="noopener">ACME 文档</a></li><li><a href="https://letsencrypt.org/zh-cn/how-it-works/" target="_blank" rel="noopener">Let’s Encrypt 的运作方式</a></li><li><a href="https://letsencrypt.org/zh-cn/docs/client-options/" target="_blank" rel="noopener">ACME 客户端</a></li></ul><blockquote><p>为了在您的网站上启用 HTTPS，您需要从证书颁发机构（CA）获取证书（一种文件）。Let’s Encrypt 是一个证书颁发机构（CA）。要从 Let’s Encrypt 获取您网站域名的证书，您必须证明您对域名的实际控制权。您可以在您的 Web 主机上运行使用 ACME 协议的软件来获取 Let’s Encrypt 证书。</p></blockquote><h3 id="API网关启用-ACME"><a href="#API网关启用-ACME" class="headerlink" title="API网关启用 ACME"></a><code>API网关</code>启用 <code>ACME</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MICRO_ENABLE_ACME=<span class="literal">true</span> micro api</span><br></pre></td></tr></table></figure><h3 id="配置白名单"><a href="#配置白名单" class="headerlink" title="配置白名单"></a>配置白名单</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MICRO_ENABLE_ACME=<span class="literal">true</span> \</span><br><span class="line">MICRO_ACME_HOSTS=example.com,api.example.com \</span><br><span class="line">micro api</span><br></pre></td></tr></table></figure><h2 id="设置-TLS-证书"><a href="#设置-TLS-证书" class="headerlink" title="设置 TLS 证书"></a>设置 <code>TLS</code> 证书</h2><p>API服务支持TLS证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MICRO_ENABLE_TLS=<span class="literal">true</span> \</span><br><span class="line">MICRO_TLS_CERT_FILE=/path/to/cert \</span><br><span class="line">MICRO_TLS_KEY_FILE=/path/to/key \</span><br><span class="line">micro api</span><br></pre></td></tr></table></figure><h2 id="设置命名空间"><a href="#设置命名空间" class="headerlink" title="设置命名空间"></a>设置命名空间</h2><p>API使用带分隔符的命名空间来在逻辑上区分后台服务及公开的服务。命名空间及 <code>http</code> 请求路径会用于解析服务名与方法，比如 <code>GET /foo HTTP/1.1</code> 会被路由到 <code>go.micro.api.foo</code> 服务上。</p><p>API默认的命名空间是 <code>go.micro.api</code>，当然，也可以修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MICRO_NAMESPACE=com.example.api micro api</span><br></pre></td></tr></table></figure><p>通过设置命名空间为为空禁用命名空间，不建议禁用命名空间，如果非要禁用，可以通过以下方法设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MICRO_NAMESPACE=<span class="string">' '</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go Micro </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 pprof 调试 golang 应用</title>
      <link href="/2020/04/05/%E7%BC%96%E7%A8%8B/%E8%B0%83%E8%AF%95/how-to-use-go-pprof/"/>
      <url>/2020/04/05/%E7%BC%96%E7%A8%8B/%E8%B0%83%E8%AF%95/how-to-use-go-pprof/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p> Golang 是一个对性能要求很高的语言，<br>因此语言中自带的 pprof 工具成为我们检测 Golang 开发应用性能的利器。 </p></blockquote><a id="more"></a><p>Google 开发的 Golang 自 2009 年推出，已经日趋成为各大公司开发后端服务使用的语言，有名的基于 Golang 的开源项目有 Docker、Kubernetes 等。当使用 Golang 开发服务后端服务时，难免产生性能问题，如内存泄漏、Goroutine 卡死等，Golang 是一个对性能要求很高的语言，因此语言中自带的 <code>pprof</code> 工具成为我们检测 Golang 开发应用性能的利器。</p><p><code>Profiling</code> 一般翻译为 画像，在计算机领域，我们可以将其理解为当前应用状态的画像。当程序性能不佳时，我们希望知道应用在 什么地方 耗费了 多少 CPU、memory。下面将介绍如何使用这一工具。</p><h2 id="Golang-服务主要关注的应用运行情况包含以下几种"><a href="#Golang-服务主要关注的应用运行情况包含以下几种" class="headerlink" title="Golang 服务主要关注的应用运行情况包含以下几种"></a>Golang 服务主要关注的应用运行情况包含以下几种</h2><ul><li>CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据</li><li>Memory Profile（Heap Profile）：报告程序的内存使用情况</li><li>Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈</li><li>Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的</li></ul><h2 id="两种使用方式"><a href="#两种使用方式" class="headerlink" title="两种使用方式"></a>两种使用方式</h2><p>go 语言提供了 <code>runtime/pprof</code> 和 <code>net/http/pprof</code> 两个库，这部分我们讲讲它们的用法以及使用场景。</p><h3 id="工具型应用"><a href="#工具型应用" class="headerlink" title="工具型应用"></a>工具型应用</h3><p>工具型应用: 如果应用是命令行应用，程序启动后，在一段时间(短期运行)内会随着处理完成而关闭。</p><p>工具型应用使用使用 <code>runtime/pprof</code> 库， 可以产生 dump 文件，应用退出的时候把 profiling 的报告保存到文件中，进行分析。</p><p>将  <code>runtime/pprof</code> 导入 main.go </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"runtime/pprof"</span></span><br></pre></td></tr></table></figure><p>其中 <code>pprof</code> 封装了很好的接口供我们使用，比如要想进行 CPU Profiling，可以调用 pprof.<code>StartCPUProfile()</code> 方法，它会对当前应用程序进行 CPU profiling，并写入到提供的参数中<code>(w io.Writer)</code>，要停止调用 <code>StopCPUProfile()</code> 即可。</p><p>去除错误处理只需要以下内容，一般把部分内容写在 main.go 文件中，应用程序启动之后就开始执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(*cpuprofile)</span><br><span class="line">...</span><br><span class="line">pprof.StartCPUProfile(f)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure><p>应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。</p><p>想要获得内存的数据，直接使用 WriteHeapProfile 就行，不用 start 和 stop 这两个步骤了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Create(*memprofile)</span><br><span class="line">pprof.WriteHeapProfile(f)</span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure><h3 id="服务型应用"><a href="#服务型应用" class="headerlink" title="服务型应用"></a>服务型应用</h3><p>服务型应用: 如果应用是一直运行(长期运行)的，比如 web 应用，那么可以使用 <code>net/http/pprof</code> 库，它能够在提供 HTTP 服务进行分析。</p><p>服务型应用使用 <code>net/http/pprof</code> 库， 其中 <code>net/http/pprof</code> 使用 <code>runtime/pprof</code> 包来进行封装，并在 http 端口上暴露出来。</p><p>如果使用了默认的 <code>http.DefaultServeMux</code>（通常是代码直接使用 <code>http.ListenAndServe(&quot;0.0.0.0:8000&quot;, nil)</code>），只需要添加一行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">"net/http/pprof"</span></span><br></pre></td></tr></table></figure><p>如果应用使用了自定义的 <code>Mux</code>，则需要手动注册一些路由规则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/"</span>, pprof.Index)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/cmdline"</span>, pprof.Cmdline)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/profile"</span>, pprof.Profile)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/symbol"</span>, pprof.Symbol)</span><br><span class="line">r.HandleFunc(<span class="string">"/debug/pprof/trace"</span>, pprof.Trace)</span><br></pre></td></tr></table></figure><p>服务起来之后，就会多多一条路由，如 <code>http://127.0.0.1:8000/debug/pprof</code> ，有以下输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/debug/pprof/</span><br><span class="line"> </span><br><span class="line">profiles:</span><br><span class="line">0    block</span><br><span class="line">62    goroutine</span><br><span class="line">444    heap</span><br><span class="line">30    threadcreate</span><br><span class="line"> </span><br><span class="line">full goroutine stack dump</span><br></pre></td></tr></table></figure><p>这个路径下还有几个子页面：</p><p><code>/debug/pprof/profile</code>：访问这个链接会自动进行 CPU profiling，持续 30s，并生成一个文件供下载<br><code>/debug/pprof/heap</code>： Memory Profiling 的路径，访问这个链接会得到一个内存 Profiling 结果的文件<br><code>/debug/pprof/block</code>：block Profiling 的路径</p><h2 id="获取和分析-Profiling-数据"><a href="#获取和分析-Profiling-数据" class="headerlink" title="获取和分析 Profiling 数据"></a>获取和分析 Profiling 数据</h2><div class="note info">            <p>获取的 Profiling 数据是动态的，要想获得有效的数据，请保证应用处于较大的负载（比如正在生成中运行的服务，或者通过其他工具模拟访问压力）。否则如果应用处于空闲状态，得到的结果可能没有任何意义。 </p>          </div><p>能通过对应的库获取想要的 Profiling 数据之后（不管是文件还是 http），下一步就是要对这些数据进行保存和分析，我们可以使用 <code>go tool pprof</code> 命令行工具。</p><ul><li><code>/debug/pprof/profile</code></li><li><code>/debug/pprof/heap</code></li><li><code>/debug/pprof/block</code></li><li><code>/debug/pprof/goroutines</code></li></ul><p>go tool pprof 工具可以对以上各个路径 prof 文件进行更详细的分析，可以生成调用关系图和火焰图。</p><h3 id="生成调用关系图"><a href="#生成调用关系图" class="headerlink" title="生成调用关系图"></a>生成调用关系图</h3><ul><li>安装 graphviz 工具</li><li>分析工具使用命令 go tool pprof [binary][source]</li><li>生成关系调用图</li></ul><ol><li><p>安装 graphviz 工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Centos 6/7</span></span><br><span class="line"><span class="comment"># yum install -y graphviz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Centos 8</span></span><br><span class="line"><span class="comment"># dnf install -y graphviz</span></span><br></pre></td></tr></table></figure></li><li><p>分析工具使用命令 go tool pprof</p><pre><code class="bash">go tool pprof demo demo.prof(pprof) web  <span class="comment">#生成调用关系图，demo.svg文件</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 调试 </tag>
            
            <tag> pprof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M3O - 如何开启 debugging 调试</title>
      <link href="/2020/04/05/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-005/"/>
      <url>/2020/04/05/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-005/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>M3O - 如何开启 debugging 调试 </p></blockquote><a id="more"></a><p>Go-micro支持设置日志打印级别以及采集运行概要。</p><h2 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h2><p>调整日志级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MICRO_LOG_LEVEL=debug go run main.go</span></span><br></pre></td></tr></table></figure><p>目前日志支持的级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trace</span><br><span class="line">debug</span><br><span class="line">error</span><br><span class="line">info</span><br></pre></td></tr></table></figure><h2 id="Profiling-运行概要"><a href="#Profiling-运行概要" class="headerlink" title="Profiling 运行概要"></a>Profiling 运行概要</h2><p>支持激活Go pprof采集运行概要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MICRO_DEBUG_PROFILE=true go run main.go</span></span><br></pre></td></tr></table></figure><p>该变量会激活cpu及内存heap运行的信息到 /tmp/[service name].[service version].{cpu, mem}.pprof中。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go Micro </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M3O - 微服务的设计模式</title>
      <link href="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/"/>
      <url>/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>M3O - 微服务的架构设计 </p></blockquote><a id="more"></a><p>原文 <a href="https://micro.mu/blog/2016/04/18/micro-architecture.html" target="_blank" rel="noopener" title="Micro architecture &amp; design patterns for microservices">Micro architecture &amp; design patterns for microservices</a><br>本文添加部分译者的理解，如有不当之处，欢迎指正。</p><h2 id="关于-Micro"><a href="#关于-Micro" class="headerlink" title="关于 Micro"></a>关于 Micro</h2><p>Micro 是一个微服务工具组件。 它的功能和接口值得一看，同时提供了强大的可插拔体系结构。</p><p>Micro 专注于满足构建微服务的基本要求，并希望通过采取谨慎的设计方法来做到这一点。</p><p>关于Micro 工具组件的介绍，可以参考之前文章阅读。</p><ul><li><a href="https://wallenotes.github.io/2020/02/25/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001/" target="_blank" rel="noopener" title="Go Micro微服务架构组成">Go Micro微服务架构组成</a></li><li><a href="https://wallenotes.github.io/2020/03/14/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-002/" target="_blank" rel="noopener" title="Go Micro微服务架构特性">Go Micro微服务架构特性</a></li></ul><p>以上是快速回顾，现在让我们更深入。</p><h2 id="RPC，REST，Proto-…"><a href="#RPC，REST，Proto-…" class="headerlink" title="RPC，REST，Proto …"></a>RPC，REST，Proto …</h2><ul><li>首先想到的是服务间通信为什么使用的是 RPC? 为什么不使用 REST？ </li><li>为什么要使用 <code>protobuf</code> 编码？</li></ul><p>Google 是 <code>protobuf</code> 的创建者，内部使用 RPC，以及其开源的 gRPC（RPC框架）。很多的大公司都是 <code>RPC/Protobuf</code> 坚定拥护者，例如 Uber、FB等。</p><p>站在巨人的肩膀上，我们并不孤单。</p><p>就个人而言，我们认为，未来的 API 会使用 RPC 构建，因为它们定义良好的结构化格式，易于与有效的编码协议（例如 protobuf ）结合使用，并提供强大定义的 API 和高效的通信功能。</p><h2 id="HTTP-到-RPC-API-…"><a href="#HTTP-到-RPC-API-…" class="headerlink" title="HTTP 到 RPC / API …"></a>HTTP 到 RPC / API …</h2><p>从现实的角度来讲，要是实现 RPC On Web，我们还有很长的路要走。 虽然它在数据中心内部是完美的，但是让它服务于公众流量(例如: web网站/ 移动服务)，那就是另外一回事了。这是 micro 包含 API 网关来服务和转换 HTTP 请求的原因之一。</p><p>API 网关是用于微服务架构的模式。 它充当外界的单一入口点，并根据请求路由到适当的服务。 这允许 HTTP API 本身由不同的微服务组成, 这是一种强大的架构模式。对 API 的一部分进行更改可能会破坏整个依赖链上服务的日子已经一去不复返了。</p><p><code>Micro API</code> 使用服务路径解析，因此每个唯一的请求路径可以由不同的 <code>micro api</code>服务提供服务, 例如: </p><ul><li><code>/user</code> =&gt; user api</li><li><code>/order</code> =&gt; order api</li></ul><p><strong>* 举例 *</strong></p><ul><li>URL: <code>/customer/orders</code></li><li>Method: <code>Customer.Orders</code> </li><li>Service: <code>go.micro.api.customer</code></li></ul><p>这是一个例子，对 <code>/customer/orders</code> 的请求将通过方法 Customer.Orders 发送到API服务 <code>go.micro.api.customer</code> 。</p><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/api.png" class=""><h2 id="那么-Micro-API-到底是什么"><a href="#那么-Micro-API-到底是什么" class="headerlink" title="那么 Micro API 到底是什么?"></a>那么 Micro API 到底是什么?</h2><ul><li>服务类型</li><li>命名空间</li><li>同步与异步</li></ul><h2 id="服务类型"><a href="#服务类型" class="headerlink" title="服务类型"></a>服务类型</h2><div class="note info">            <p>让每个程序就做好一件事。如果有新任务，就重新开始，不要往原程序中加入新功能而搞得复杂。<br>    - Doug McIlroy (Unix管道的发明人、Unix传统的奠基人之一)</p>          </div><p>微服务的概念全都涉及服务按照职能的分离，并且从 Unix 哲学中汲取了很多东西: 一个程序只做一件事，并做好。还有部分原因是我们认为在职责不同的服务之间需要逻辑上和架构上的分离。</p><p>现在，我将承认这些概念并不是什么新鲜事物，但是鉴于它们已经在非常成功的大型技术公司中得到证明，因此它们令人信服。 我们的目标是传播这些开发理念，并通过工具指导设计决策。</p><p>因此，这是我们当前定义的服务类型。</p><ul><li><p>API - 由 <code>micro api</code> 提供的 API 服务位于您的基础架构的接入层，最有可能服务于外部请求。 您可以使用 HTTP 处理程序来构建它，并以反向代理模式运行 <code>micro api</code>，或者默认情况下处理特定的 RPC API 请求响应格式。</p></li><li><p>WEB - 由 <code>micro web</code> 提供的 Web 服务专注于提供 html 内容和仪表板。 <code>micro web</code> 反向代理 HTTP 和 WebSockets。 这些是目前唯一受支持的协议，但将来可能会扩展。 </p></li><li><p>SRV - 这些是基于 RPC 的后端服务。 他们主要致力于为您的系统提供核心功能，并且很可能不是面向公众的。 如果愿意，您仍然可以使用 <code>/rpc</code> 端点通过 <code>micro api</code> 或 Web访问它们，但更有可能的是 API，Web 和其他 SRV 服务使用 <code>go-micro</code> 客户端直接调用它们。</p></li></ul><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/arch.png" class=""><p>根据过去的经验，我们发现这种架构模式非常强大，并且可以扩展到数百种服务。 通过将这种服务类型构建到整个架构体系中，我们认为它为微服务开发奠定了良好的基础。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>因此，您可能想知道，是什么协调了 <code>micro api</code> 与 web 服务的对话或 <code>micro web</code> 与 api 服务的对话。 我们使用逻辑命名空间将其分开。 通过在服务名称之前添加名称空间，我们可以清楚地标识其用途和在系统中的位置。 这是一个简单但有效的模式，对我们很有帮助。</p><p><code>micro api</code>和 <code>micro web</code> 将组成名称空间的服务名称和请求路径的第一个路径，例如，对 <code>/api/customer</code> 的请求将变为 <code>go.micro.api.customer</code> 。</p><p>默认名称空间是：</p><p>API - <code>go.micro.api</code><br>WEB - <code>go.micro.web</code><br>SRV - <code>go.micro.srv</code></p><p>您应该将这些设置为您的域，例如 <code>com.example.{api,web,srv}</code> 。 可以在运行时配置 <code>micro api</code> 和 <code>micro web</code>，以路由到您的名称空间。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>您经常会在与响应模式相同的句子中听到微服务。 对于许多人来说，微服务是关于创建事件驱动的体系结构和设计主要通过异步通信进行交互的服务。</p><p>Micro 将建议优先使用异步通信，这是微服务的基本构建模块。通过异步消息传递通信事件，任何人都可以使用它们并对其采取行动。 可以构建新的独立服务，而无需对系统的其他方面进行任何修改。 这是一种强大的设计模式，因此，我们在 <code>go-micro</code> 中包含了 Broker 接口。</p><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/pub-sub.png" class=""><p>在 Micro 中，同步和异步通信作为单独的要求解决。 传输接口用于在服务之间创建点对点连接。 <code>go-micro</code> 客户端和服务器在传输基础上构建，以执行请求-响应RPC并提供双向流功能。</p><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/request-response.png" class=""><p>在构建系统时，应同时使用两种通信方式，但了解何时以及何处适当才是关键。 在很多情况下，没有对与错，而是会进行一定的权衡。</p><p>以下是异步通信在一个审计跟踪系统中的使用，该系统用于跟踪客户事件历史记录。</p><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/audit.png" class=""><p>在此示例中，当发生某些操作（例如客户登录，更新其个人资料或下订单）时，每个API或服务都会发布一个事件。 审核服务将订阅这些事件，并将它们存储在某种时间序列数据库中。 然后，管理员或其他任何人都可以查看任何用户在系统内发生的事件的历史记录。</p><p>如果将其作为同步呼叫完成，那么在流量很大或并发请求数量较高时，我们很容易使审计服务不堪重负。 如果由于某种原因使审计服务不可用或呼叫失败，我们将基本上失去此历史记录。 通过将这些事件发布给代理，我们可以异步保留它们。 这是事件驱动架构和微服务中的常见模式。</p><h2 id="G3O-是如何定义微服务的？"><a href="#G3O-是如何定义微服务的？" class="headerlink" title="G3O 是如何定义微服务的？"></a>G3O 是如何定义微服务的？</h2><blockquote><p>我们的信念和建立的思想是，微服务是专注于单一类型的实体或域的应用程序，它通过强定义的API提供对它的访问。</p></blockquote><p>让我们使用诸如社交网络之类的真实示例。</p><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/facebook.png" class=""><p>随着 <code>Ruby on Rails</code> 的兴起而流行的一种定义明确的软件体系结构模式是 <code>MVC</code>（模型-视图-控制器)。</p><p>在 <code>MVC</code> 世界中，每个实体或域都将代表一个模型，该模型又将数据库抽象化。 该模型可以与其他模型具有关系，例如一对多或多对多。 控制器处理即将到来的请求，从模型中检索数据并将其传递给视图以呈现给用户。</p><p>现在相同的示例，以微服务架构为例。 这些模型中的每一个都是服务，并通过API传递其数据。 用户请求，数据收集和呈现由许多不同的Web服务处理。</p><p>每个服务都有一个重点。 当我们想要添加新功能或实体时，我们可以简单地更改与该功能相关的一项服务或编写一项新服务。 功能点的分离为弹性软件开发提供了一种模式。</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/versioning.png" class=""><p>版本控制是开发实际软件的重要部分。 在微服务领域，鉴于API和业务逻辑分散在许多不同的服务中，这一点至关重要。 因此，将服务版本控制作为核心工具的一部分，允许对更新和流量整形进行更精细的控制非常重要。</p><p>在 <code>go-micro</code> 中，通过名称和版本定义服务。 注册表将服务作为列表返回，按节点注册时的版本划分节点。</p><p>这是我们基于版本的路由的构建模块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123; </span><br><span class="line">Name <span class="keyword">string</span> </span><br><span class="line">Version <span class="keyword">string</span> </span><br><span class="line">Metadata <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> </span><br><span class="line">Endpoints []*Endpoint </span><br><span class="line">Nodes []*Node </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合使用 <code>go-micro</code> 中的客户端负载均衡器 <code>Selector</code> ，可以确保将请求相应地分配到各个版本中。</p><p>选择器是一个强大的接口，我们正在构建该接口以提供不同类型的路由算法。 默认是随机算法，并且支持轮询、以及基于标签、基于延迟的方式。</p><p>通过使用默认的随机哈希负载平衡算法并逐渐添加新服务版本的实例，您可以执行蓝绿色部署并进行灰度测试。</p><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/selector.png" class=""><p>将来，我们将寻求实现一个全局服务负载平衡器，该平衡器将与选择器绑定在一起，从而可以根据正在运行的系统中的历史趋势进行路由决策。 它还将能够在运行时调整发送到服务的每个版本的流量的百分比，并为服务动态添加元数据或标签，从而可以基于标签做出路由决策。</p><h2 id="扩展能力"><a href="#扩展能力" class="headerlink" title="扩展能力"></a>扩展能力</h2><p>上面有关版本控制的评论开始暗示扩展服务的基本模式。 尽管注册表用作存储有关服务信息的机制，但我们使用选择器将路由和负载平衡的考虑分开。</p><p>同样，服务按照职能的拆分和让每个程序就做好一件事的概念。 扩展基础结构以及代码的重点在于简单性，严格定义的 API 和分层体系结构。 通过创建这些构建块，我们允许我们自己构建更多可伸缩的软件并解决其他地方的更高层次的问题。</p><p>这是 Micro 编写方式以及我们希望如何指导微服务世界中的软件开发的基础。</p><p>在生产环境中部署服务时，您将寻求构建可伸缩，容错和高性能的产品。 现在，云计算使我们可以访问几乎无限的规模，但是没有什么可以避免失败。 实际上，故障是我们在构建分布式系统时要解决的关键方面之一，并且在构建基础结构时应考虑到这一点。</p><p>在云世界中，我们希望容忍可用区（数据中心）故障，甚至整个区域（多DC）中断。 在过去的几天中，我们经常谈论冷热备用系统或灾难恢复计划。 如今，最先进的技术公司以全球化的方式开展业务，每个应用程序的多个副本在全球多个数据中心中运行。</p><p>我们需要向 Google，Facebook，Netflix和 Twitter 等公司学习。 我们必须构建能够容忍AZ故障而又不对用户造成任何影响的系统，并且在大多数情况下，我们必须在几分钟或更短的时间内处理区域故障。</p><p>Micro 使您能够构建这种架构。 通过提供可插拔接口，我们可以利用最合适的分布式系统来满足 micro 工具箱的每个需求。</p><p>服务发现和注册表是 Micro 的基础。 它可用于隔离和发现AZ或区域或您选择的任何配置中的一组服务。 然后，可以使用Micro API在该拓扑中路由和平衡许多服务及其实例。</p><img src="/2020/03/28/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-004/regions.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望这篇博文可以使您更清楚地了解 Micro 的体系结构，以及它如何为微服务实现可扩展的设计模式。</p><div class="note info">            <ul><li>微服务首先是软件设计模式。 我们可以通过工具启用某些基础模式，同时为其他模式的出现或使用提供灵活性。</li><li>由于 Micro 是可插拔的体系结构，因此它是各种设计模式的强大支持者，可以在许多情况下适当使用。 <blockquote><p>例如，如果您正在构建视频流基础结构，则可以选择 HTTP 传输进行点对点通信。 如果您对延迟不敏感，则可以选择传输插件，例如 NATS 或 RabbitMQ。</p></blockquote></li></ul>          </div>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go Micro </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Micro微服务架构 - 快速上手</title>
      <link href="/2020/03/22/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-003/"/>
      <url>/2020/03/22/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-003/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>本文主要将如何快速启动 M3O 微服务 </p></blockquote><a id="more"></a><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><ul><li>依赖</li><li>安装</li><li>编写服务</li></ul><!-- more --><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p><strong>Protobuf</strong></p><p>代码生成依赖 Protobuf , 安装示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/micro/protoc-gen-micro/v2</span><br></pre></td></tr></table></figure><p><strong>Discovery</strong></p><p>推荐使用 etcd 作为注册中心。</p><p><strong>etcd</strong></p><p>单机部署参考 Dockerfile, 安装示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM k8s.gcr.io/debian-base:v1.0.0</span><br><span class="line"></span><br><span class="line">ADD etcd /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">ADD etcdctl /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">RUN mkdir -p /var/etcd/</span><br><span class="line">RUN mkdir -p /var/lib/etcd/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alpine Linux doesn't use pam, which means that there is no /etc/nsswitch.conf,</span></span><br><span class="line"><span class="comment"># but Golang relies on /etc/nsswitch.conf to check the order of DNS resolving</span></span><br><span class="line"><span class="comment"># (see https://github.com/golang/go/commit/9dee7771f561cf6aee081c0af6658cc81fac3918)</span></span><br><span class="line"><span class="comment"># To fix this we just create /etc/nsswitch.conf and add the following line:</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4'</span> &gt;&gt; /etc/nsswitch.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 2379 2380</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define default command.</span></span><br><span class="line">CMD [<span class="string">"/usr/local/bin/etcd"</span>]</span><br></pre></td></tr></table></figure><p>使用当前目录作为上下文的构建命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build .</span><br></pre></td></tr></table></figure><h2 id="安装-go-micro"><a href="#安装-go-micro" class="headerlink" title="安装 go-micro"></a>安装 go-micro</h2><p>Go Micro是用于基于Go的开发的框架。</p><p>服务中导入 go-micro 示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/micro/go-micro/v2"</span></span><br></pre></td></tr></table></figure><p>建议开启 go mod，并通过 go mod 启用改功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enable go modules</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="comment"># initialise go modules in your app</span></span><br><span class="line">go mod init</span><br><span class="line"><span class="comment"># now go get</span></span><br><span class="line">go get ./...</span><br></pre></td></tr></table></figure><h2 id="编写服务"><a href="#编写服务" class="headerlink" title="编写服务"></a>编写服务</h2><p>按照惯例，使用 go-micro 编写一个 helloworld服务，以下是具体步骤。</p><ul><li>服务原型</li><li>生成原型</li><li>编写服务</li><li>运行服务</li><li>定义客户端</li><li>运行客户端</li></ul><blockquote><p>以下操作均在 greeter 目录下进行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /home/eter/greeter</span></span><br></pre></td></tr></table></figure><h3 id="服务原型"><a href="#服务原型" class="headerlink" title="服务原型"></a>服务原型</h3><p>创建 proto 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir proto</span></span><br><span class="line"><span class="comment"># touch proto/greeter.proto</span></span><br></pre></td></tr></table></figure><p>编辑 proto/greeter.proto 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">rpc Hello(HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">string greeting &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看下 greeter 目录，可以看到 proto 目录中只有 greeter.proto 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greeter</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── proto</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure><h3 id="生成原型"><a href="#生成原型" class="headerlink" title="生成原型"></a>生成原型</h3><p>在定义好原型后我们得使用 protoc ，以及 micro 插件编译它，micro 插件可以帮助生成 go micro 需要的原型文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=<span class="variable">$GOPATH</span>/src:. --micro_out=. --go_out=. proto/greeter.proto</span><br></pre></td></tr></table></figure><p>查看下 greeter 目录，可以看到 proto 目录中生成的文件 greeter.pb.go 以及 greeter.pb.micro.go 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">greeter</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure><h3 id="编写服务-1"><a href="#编写服务-1" class="headerlink" title="编写服务"></a>编写服务</h3><ol><li>首先编辑greeter的服务代码 main.go 文件</li></ol><p>主要功能:</p><ul><li>定义并实现Greeter Handler中的接口</li><li>初始化 micro.Service</li><li>注册 Greeter Handler</li><li>运行服务</li></ul><p>main.go 代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">micro <span class="string">"github.com/micro/go-micro/v2"</span></span><br><span class="line">proto <span class="string">"github.com/eopenio/greeter/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Greeter)</span> <span class="title">Hello</span><span class="params">(ctx context.Context, req *proto.HelloRequest, rsp *proto.HelloResponse)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">rsp.Greeting = <span class="string">"Hello "</span> + req.Name</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建新的服务</span></span><br><span class="line">service := micro.NewService(</span><br><span class="line">    micro.Name(<span class="string">"greeter"</span>),</span><br><span class="line">    micro.Version(<span class="string">"v0.0.1"</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务，并且解析命令行传参</span></span><br><span class="line">service.Init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterGreeterHandler</span></span><br><span class="line">proto.RegisterGreeterHandler(service.Server(), <span class="built_in">new</span>(Greeter))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line"><span class="keyword">if</span> err := service.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看下 greeter 目录，可以看到新增 main.go 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">greeter</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">### 运行服务</span><br><span class="line">&#96;&#96;&#96; bash</span><br><span class="line"># go run main.go</span><br><span class="line">2020-03-22 20:57:40  level&#x3D;info Starting [service] greeter</span><br><span class="line">2020-03-22 20:57:40  level&#x3D;info Server [grpc] Listening on [::]:65461</span><br><span class="line">2020-03-22 20:57:40  level&#x3D;info Registry [etcd] Registering node: greeter-45fc8d75-1db5-48f0-8f5d-71a691e5c982</span><br></pre></td></tr></table></figure><p>通过 micro 命令进行查看服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># micro list services</span><br><span class="line">greeter</span><br><span class="line"></span><br><span class="line"># micro get service greeter</span><br><span class="line">service  greeter</span><br><span class="line"></span><br><span class="line">version v0.0.1</span><br><span class="line"></span><br><span class="line">ID      Address Metadata</span><br><span class="line">greeter-45fc8d75-1db5-48f0-8f5d-71a691e5c982    192.168.3.5:65461       transport&#x3D;grpc,broker&#x3D;eats,protocol&#x3D;grpc,registry&#x3D;etcd,server&#x3D;grpc</span><br><span class="line"></span><br><span class="line">Endpoint: Greeter.Hello</span><br><span class="line"></span><br><span class="line">Request: &#123;</span><br><span class="line">        name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response: &#123;</span><br><span class="line">        greeting string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义客户端"><a href="#定义客户端" class="headerlink" title="定义客户端"></a>定义客户端</h3><p>新增客户端代码 cli.go 文件。</p><p>cli.go 代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">micro <span class="string">"github.com/micro/go-micro/v2"</span></span><br><span class="line">proto <span class="string">"github.com/eopenio/greeter/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建新服务</span></span><br><span class="line">service := micro.NewService(micro.Name(<span class="string">"greeter.client"</span>))</span><br><span class="line">service.Init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的客户端</span></span><br><span class="line">greeter := proto.NewGreeterService(<span class="string">"greeter"</span>, service.Client())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用greeter</span></span><br><span class="line">rsp, err := greeter.Hello(context.TODO(), &amp;proto.HelloRequest&#123;Name: <span class="string">"World"</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印响应请求</span></span><br><span class="line">fmt.Println(rsp.Greeting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greeter</span><br><span class="line">├── cli.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure><h3 id="运行客户端"><a href="#运行客户端" class="headerlink" title="运行客户端"></a>运行客户端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">go</span> run cli.<span class="keyword">go</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><blockquote><p>本文示例可以通过以下命令，进行编译.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone https://github.com/eopenio/greeter.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务端</span></span><br><span class="line"><span class="comment"># go run main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动客户端</span></span><br><span class="line"><span class="comment"># go run cli.go</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go Micro </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Micro微服务架构特性</title>
      <link href="/2020/03/14/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-002/"/>
      <url>/2020/03/14/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-002/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>本文主要概述M3O微服务架构特性 </p></blockquote><a id="more"></a><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>Go Micro 是微服务开发的框架。</p><blockquote><p>Go Micro 提供了分布式系统开发的核心要求，包括 RPC 和事件驱动的通信。 微哲学是可插拔体系结构的默认设置。 我们提供了默认设置，可帮助您快速入门，但所有内容都可以轻松换出。</p></blockquote><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>Go Micro 主要功能：</p><ul><li><p>服务发现（Service Discovery）- 自动服务注册和名称解析，服务发现是微服务开发的核心。 当服务A需要与服务B通信时，它需要该服务的位置。 默认发现机制是多播 DNS（mdns），一种零配置系统，推荐使用 etcd 。</p></li><li><p>负载平衡（Load Balancing）- 基于服务发现的客户端负载平衡。 当获得了服务的任意数量的实例的地址，我们现在需要一种方法来确定要路由到的节点。 我们使用随机散列负载平衡来提供服务之间的平均分配，并在出现问题时重试其他节点。</p></li><li><p>消息编码 （Message Encoding）- 基于内容类型的动态消息编码。 客户端和服务端会一起使用content-type的格式来对Go进行无缝编/解码。各种各样的消息被编码会发送到不同的客户端，客户端服服务端默认会处理这些消息。 默认情况下，包括protobuf 和 json 。</p></li><li><p>请求/响应 (Request/Response) - 基于 RPC 的请求/响应，支持双向流。 我们为同步通信提供了一个抽象。 对服务的请求将被自动解决，负载均衡，拨号和流式传输。 默认传输方式是gRPC 。</p></li><li><p>异步消息传递（Async Messaging） - 发布订阅（PubSub）头等功能内置在异步通信与事件驱动架构中。事件通知在微服务开发中处于核心位置。默认的消息传送使用点到点http/1.1，激活tls时则使用http2。</p></li><li><p>可插拔接口（Pluggable Interfaces）- Go Micro对每个分布式系统抽象都使用Go接口。 因此，这些接口是可插入的，并允许Go Micro与运行时无关。 您可以插入任何基础技术。 在github.com/micro/go-plugins中找到插件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go Micro </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TiKV is busy 处理思路</title>
      <link href="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/"/>
      <url>/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>当 TiDB 集群遇到 Server is Busy 时，常规处理思路。  </p></blockquote><a id="more"></a><p>日常 TiDB 运维中，当你在 TiKV 监控 Trouble - Shooting - Server Is Busy 看到以下这样的监控时，</p><img src="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/1.png" class="" title="[1] 图片"><p>可能此时的 TiDB 集群在该时间段内响应延时会大幅度增加，甚至会出现大量请求超时并且伴随大量告警出现。</p><h1 id="Server-is-Busy-的影响"><a href="#Server-is-Busy-的影响" class="headerlink" title="Server is Busy 的影响"></a>Server is Busy 的影响</h1><p>Server is Busy 本质上就是 tikv-server 繁忙，暂时无法对该请求做出响应，所以此时从TiDB集群到业务都会受到影响。以下从两个角度观察这个问题。</p><h2 id="1-运维角度"><a href="#1-运维角度" class="headerlink" title="1. 运维角度"></a>1. 运维角度</h2><ol><li>集群性能迅速下降，现象可以从 TiDB 监控 - Query Summary - Duration 明显看到。</li><li>TIKV 服务器负载增加，现象可以从 TiKV 监控 - Server / Thread CPU / Error 中看到。</li><li>TiDB 日志中大量的 server is busy 日志，可以查看 tidb.log 过滤 Server is Busy 关键字。</li><li>慢查询大量增加，常规基于主键查询的请求，也会很慢。</li></ol><h2 id="2-业务角度"><a href="#2-业务角度" class="headerlink" title="2. 业务角度"></a>2. 业务角度</h2><ol><li>业务访问数据库响应耗时大幅度增加， 例如： 5ms -&gt; 5s。</li><li>业务告警，数据库访问超时，例如： TimeoutException。</li><li>部分请求访问DB不响应。</li></ol><p>每次出现 Server is Busy 对于运维以及业务都是比较紧张，那么接下来分析一下 Server is busy 的原因。</p><h1 id="Server-is-Busy-的原因"><a href="#Server-is-Busy-的原因" class="headerlink" title="Server is Busy 的原因"></a>Server is Busy 的原因</h1><h2 id="写保护-write-stall"><a href="#写保护-write-stall" class="headerlink" title="写保护 ( write stall )"></a>写保护 ( write stall )</h2><p>TiKV 底层有 2 个 RocksDB 作为存储,  RocksDB 使用的 LSM Tree，LSM Tree 牺牲了一部分读的性能和增加了合并的开销，换取了高效的写性能，但如果写入过快，超过了 RocksDB 处理的极限，RocksDB 就会考虑对写入进行降速处理。</p><ul><li>密集写入，导致 level0 sst 太多导致 stall 。</li><li>pending compaction bytes 太多导致 stall ， 服务器磁盘IO能力在写入高峰跟不上写入。</li><li>memtable 太多导致 stall 。</li></ul><img src="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/2.png" class="" title="[1] 图片"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">处理建议：</span><br><span class="line">1. 是否存在热点写入&#x2F;写入倾斜，是否可以打散写入</span><br><span class="line">2. 调整 rocksdb 参数 max-sub-compactions 至 2~3，将 level0 到 level1 的 compaction 拆分为多个子任务，加快并行 compaction 的速度</span><br><span class="line">3. 适当调大 level0-slowdown-writes-trigger &#x3D; 40，level0-stop-writes-trigger &#x3D; 56，这不一定能根本解决问题，只是加大了限制进行缓解</span><br></pre></td></tr></table></figure><h2 id="scheduler-too-busy"><a href="#scheduler-too-busy" class="headerlink" title="scheduler too busy"></a>scheduler too busy</h2><ul><li><p>写入冲突严重，两阶段提交时都需要申请 latch，如果冲突严重，latch 申请就会排队，导致 latch wait duration 比较高, 现象 TIKV 监控 -  scheduler prewrite|commit 的 latch wait duration</p></li><li><p>写入慢导致写入堆积，该 TiKV 正在写入的数据超过了 [storage] scheduler-pending-write-threshold = “100MB” 设置的阈值。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">处理建议：</span><br><span class="line">1. 是否可以将针对单行数据的并行写入，改为串行写入</span><br><span class="line">2. 可以考虑分布式锁</span><br><span class="line">3. 开启悲观事务</span><br></pre></td></tr></table></figure><h2 id="线程池排队"><a href="#线程池排队" class="headerlink" title="线程池排队"></a>线程池排队</h2><p>常规的线程池设计中，请求处理的越快，线程池压力越小，整体处理能力就越强。当单个请求变慢时，整个线程池也不受影响，当变慢的请求逐渐堆积时，整个线程池也会逐渐变得处理能力下降甚至不响应。超出线程池上限后会返回 Server Is Busy。</p><p>(1) 关键配置 tikv.yml</p><p>在 3.0 的版本中，不同的查询会在 2 套线程池中执行，分别是 <strong>readpool.storage 和 readpool.coprocessor</strong>，每个线程池分为三个优先级，分别用于处理高优先级，普通优先级和低优先级请求。 TiDB 点查选择是高优先级，范围扫描是普通优先级，而诸如表分析之类的后台作业是低优先级。</p><p>既然是使用线程池处理请求，接下来看下线程池的限制，线程数，以及单个线程允许积压的最大任务数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 高优先级线程池, 默认值 cpu core 数 * 80%, 最小值 1</span><br><span class="line">high-concurrency</span><br><span class="line">&#x2F;&#x2F; 普通优先级线程池, 默认值 cpu core 数 * 80%, 最小值 1</span><br><span class="line">normal-concurrency</span><br><span class="line">&#x2F;&#x2F; 低优先级线程池, 默认值 cpu core 数 * 80%, 最小值 1</span><br><span class="line">low-concurrency</span><br><span class="line">&#x2F;&#x2F; 指定低优先级线程池中每个线程的最大运行操作数，处理高优先级读取请求</span><br><span class="line">&#x2F;&#x2F; 默认值 2000, 最小值 2000</span><br><span class="line">max-tasks-per-worker-high</span><br><span class="line">&#x2F;&#x2F; 指定低优先级线程池中每个线程的最大运行操作数，处理低普通先级读取请求</span><br><span class="line">max-tasks-per-worker-normal</span><br><span class="line">&#x2F;&#x2F; 指定低优先级线程池中每个线程的最大运行操作数，处理低优先级读取请求</span><br><span class="line">max-tasks-per-worker-low</span><br></pre></td></tr></table></figure><p>其中以高优先线程池为例，因为调整线程资源的是线程池级别而不是单线程级别，所以高优先级线程池默认最大运行操作数的限制为  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max-tasks-per-worker-high * high-concurrency &#x3D; 2000 * 4 &#x3D; 8000</span><br></pre></td></tr></table></figure><p>(2) 推荐配置（针对 <strong><em>TiDB</em></strong> 集群）</p><ul><li>单机单实例( TiKV )，不应超过服务器 CPU 核数<ul><li>例如：一台 48 Core 服务器运行 1 个 tikv-server，则每个实例的高并发值应小于 48</li><li>最大性能推荐值：<strong>48</strong></li><li>均衡性能推荐值：<strong>36</strong></li></ul></li><li>单机多实例(TIKV)，<ul><li>例如：一台 48 Core 服务器运行 3 个 tikv-server，则每个实例的高并发值应小于 16</li><li>最大性能推荐值：<strong>16</strong></li><li>均衡性能推荐值：<strong>12</strong></li></ul></li></ul><p>(3) 4.0 的线程池整合</p><p>从 4.0 版本开始，将 readpool.storage 和 readpool.coprocessor  整合为一个 unified read pool 线程池，并且不再需要配置3 个优先级，解决资源分配不均的问题，并且大大提高了使用体验，相关配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[readpool]</span><br><span class="line"># unify-read-pool &#x3D; true</span><br><span class="line"></span><br><span class="line">[readpool.unified]</span><br><span class="line"># min-thread-count &#x3D; 1</span><br><span class="line"># max-thread-count &#x3D; 8</span><br><span class="line"></span><br><span class="line">## Size of the stack for each thread in the thread pool.</span><br><span class="line"># stack-size &#x3D; &quot;10MB&quot;</span><br><span class="line"></span><br><span class="line">## Max running tasks of each worker, reject if exceeded.</span><br><span class="line"># max-tasks-per-worker &#x3D; 2000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理建议：</span><br><span class="line">1. 考虑是否出现大量扫描现象。</span><br><span class="line">2. 考虑是否是可用线程较少，可以通过增加 TIKV 节点提高集群整体处理能力</span><br></pre></td></tr></table></figure><h2 id="raftstore-is-busy"><a href="#raftstore-is-busy" class="headerlink" title="raftstore is busy"></a>raftstore is busy</h2><ul><li>append log 遇到了 stall，监控在 2 个地方可以看到<ul><li>[tikv-detail]-&gt;[RocksDB - raft]-[Write stall duration]</li><li>[tikv-detail]-&gt;[RocksDB - kv]-[Write stall duration]</li><li>以上也可以直接看 [tikv-detail]-&gt;[Errors]-&gt;[Server is busy]</li></ul></li><li>append log duration 比较高，导致处理消息不及时，监控在 [tikv-detail]-&gt;[Raft IO]-&gt;[append log duration]<ul><li>考虑 append log 慢， 查看磁盘 IO 情况， 通常是写盘慢了，查看 [tikv-detail]-&gt;[Raft IO]-&gt;[Write duration]</li><li>考虑 [raftstore] store-pool-size 配置是否过小， 该值建议在[1,5] 之间，不建议太大。可以通过 [tikv-detail]-&gt;[Thread CPU]-&gt;[Raft store CPU] 看确定是否过小，如果[Raft store CPU] 超过了 [store-pool-size 数量] * 70% 说明需要加大 store-pool-size。</li><li>通常单个 tikv-server 实例的 region 数量超过 5 万之后，region 之间的心跳也会占用很多 raftstore cpu ，建议开启 hibernate region 来解决这个问题</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[raftstore]</span><br><span class="line">hibernate-regions &#x3D; true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理建议：</span><br><span class="line">1. 考虑是否磁盘写入存在瓶颈</span><br><span class="line">2. 是否 store-pool-size 配置是否过小，适当调整参数</span><br></pre></td></tr></table></figure><p>以上为 TiKV Server is busy 的主要的几个原因，在使用 TiDB 过程中需要尽力避免过程中出现 Server is Busy 的情况，可以通过优化 SQL 优化、参数调整、增加节点等手段避免该问题。</p><h1 id="触发-Server-is-Busy-的常见场景"><a href="#触发-Server-is-Busy-的常见场景" class="headerlink" title="触发 Server is Busy 的常见场景"></a>触发 Server is Busy 的常见场景</h1><h2 id="SQL-开销较大"><a href="#SQL-开销较大" class="headerlink" title="SQL 开销较大"></a>SQL 开销较大</h2><ol><li>常规慢查询,  有很多的场景，例如：全表扫描。</li><li>大表索引未被命中正确的索引的情况。</li><li>高并发导入数据，导致 tikv 写入繁忙。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理建议：</span><br><span class="line">1. 针对开销较大的 SQL，如果是读 SQL可以做相应的 SQL 优化，来避免大量扫表。</span><br><span class="line">2. TiDB4.0 的 unified thread pool 针对这种情况有优化，高并发导入的问题可以降低导入并发。</span><br></pre></td></tr></table></figure><h2 id="事务冲突"><a href="#事务冲突" class="headerlink" title="事务冲突"></a>事务冲突</h2><p>乐观锁事务模式下事务冲突严重，会导致大量的线程进行重试，从而导致 tikv is busy，例如计数器功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理建议:</span><br><span class="line">针对*乐观锁事务模式下的事务**冲突的场景，可以通过添加分布式锁，或者使用悲观事务模型来解决。</span><br><span class="line">1. TiDB v3.0.8默认使用悲观锁事务模式，如果集群是从 v3.0.8 版本以下升级上来的集群，默认还是乐观锁事务模式。</span><br></pre></td></tr></table></figure><h2 id="集群-region-数量太大"><a href="#集群-region-数量太大" class="headerlink" title="集群 region 数量太大"></a>集群 region 数量太大</h2><p>在 TiDB 2.1 等低版本中，因为 TiKV 的 raft 是单线程，当管理的 region 数达到一定量级时，性能会下降，多大一定程度，单核只够管理 region 。并没有空闲的能力处理业务。业务就会出现 server is busy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理建议：</span><br><span class="line">1. 升级到 3.0 版本以上，设置 store-pool-size 开启多线程 raftstore</span><br><span class="line">2. 设置 hibernate-regions ，开启静默 region</span><br></pre></td></tr></table></figure><h2 id="热点问题"><a href="#热点问题" class="headerlink" title="热点问题"></a>热点问题</h2><ol><li>如果业务写入集中在某一个 region 范围内，比如自增 id 的写入，这个 region 所在的 tikv-server 的压力会增大，导致线程处理变慢，线程会出现排队，最终导致 server is busy。</li><li>客户端在短期内发起密集的写入，其中主要是热点写入，可能出现写入倾斜，并导致单个 tikv 节点出现 server is busy。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">处理建议：</span><br><span class="line">1. 对于热点更新的场景，可以通过 region 拆分、shard_row_id_bits、pre_split_regions 等方式优化。</span><br></pre></td></tr></table></figure><h2 id="常规查询变慢的原因"><a href="#常规查询变慢的原因" class="headerlink" title="常规查询变慢的原因"></a>常规查询变慢的原因</h2><p>当 Server is Busy 出现后，查询为什么突然变慢，平时 99% 6ms 返回, 为啥突然 3s 都没有返回?</p><p>如果确认是在 Server is Busy 的情况下，Query Duration 明显增加，此时可以通过观察 tidb.log 日志，可以看到，正常查询主要耗时在 wait 阶段，并不是消耗在 exec 时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">如果 coprocessor 的每个线程排队超过 2000 个任务，</span><br><span class="line">本次查询是第 2001 个任务，那么需要队列中任务任一个任务执行完成，</span><br><span class="line">后第 2001 才会开始执行，所以看似简单的查询会变慢，主要时间消耗在队列等待上面。</span><br></pre></td></tr></table></figure><h1 id="总结处理思路"><a href="#总结处理思路" class="headerlink" title="总结处理思路"></a>总结处理思路</h1><p>通过前面的原因和场景，总结一下可能的处理思路及手段如下：</p><ol><li>针对开销较大的 SQL，可以做出相应的 SQL 优化，来避免大量扫表。（4.0 的 unified thread pool 针对这种情况有优化）</li><li>针对事务冲突的场景，可以通过添加分布式锁，或者使用悲观事务模型来解决。</li><li>对于热点更新的场景，可以通过 region 拆分、shard_row_id_bits、pre_split_regions等方式优化。</li><li>如果是可用的线程较少，导致了线程池排队，可以增加 tikv 节点，来提高集群的处理能力。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> TiDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> TiDB </tag>
            
            <tag> TiKV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Micro微服务架构组成</title>
      <link href="/2020/02/25/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001/"/>
      <url>/2020/02/25/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>本文主要概述M3O微服务架构组成 </p></blockquote><a id="more"></a><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>提供的主要软件是Micro ，一个微服务开发运行时。</p><blockquote><p>Micro 解决了构建微服务系统的关键需求。 它采用微服务架构模式并将其转换为一组工具，这些工具充当可伸缩平台的构建块。Micro隐藏了分布式系统的复杂性，并为开发人员提供了易于理解的概念。</p></blockquote><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>运行时由以下功能组成：</p><img src="/2020/02/25/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001/micro-001-01.png" class="" title="[1] micro运行时提供的功能"><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>一个api网关。 使用服务发现进行动态请求路由的单个入口点。 API网关使您可以在后端构建可扩展的微服务架构，并在前端整合服务公共api的服务。 微型api通过发现和可插入处理程序提供强大的路由，以服务http，grpc，websocket，发布事件等。</p><h3 id="bot"><a href="#bot" class="headerlink" title="bot"></a>bot</h3><p>在您的平台上运行的slackbot，可让您从Slack本身管理应用程序。 微型机器人启用了ChatOps，并使您能够通过消息与团队一起完成所有工作。 它还具有将松弛命令创建为动态发现的服务的功能。</p><h3 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h3><p>交互式CLI，用于从终端描述，查询和直接与您的平台和服务交互。 CLI为您提供了您希望了解微服务正在发生的所有命令。 它还包括一个交互模式。</p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>使用微网络服务构建多云网络。 只需插入并连接任何环境中的网络服务，并创建一个单一的扁平网络即可进行全球路由。 微型网络会根据您在每个数据中心中的本地注册表动态地构建路由，以确保查询是根据位置进行路由的。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>服务模板生成器。 创建新的服务模板以快速入门。 Micro提供了用于编写微服务的预定义模板。 始终以相同的方式开始，构建相同的服务以提高生产力。</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>基于Go Micro构建的透明服务代理。 将服务发现，负载平衡，容错，消息编码，中间件，监视等卸载到一个位置。 独立运行它或与您的服务一起运行。</p><h3 id="tunnel"><a href="#tunnel" class="headerlink" title="tunnel"></a>tunnel</h3><p>无需任何VPN即可在任何环境中访问服务的网络隧道。 微隧道通过内置代理提供点对点隧道，以查询远程环境中的服务。 从本地笔记本电脑查询生产系统。</p><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p>Web仪表板使您可以浏览服务，描述其端点，请求和响应格式，甚至直接查询它们。 仪表板还包括内置的CLI（类似CLI），适用于希望即时进入终端的开发人员。</p><p>另外，micro提供了Go开发框架：</p><h3 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h3><p>利用强大的Go Micro框架轻松快速地开发微服务。Go Micro消除了分布式系统的复杂性，并提供了更简单的抽象来构建高度可扩展的微服务。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go Micro </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年更新计划</title>
      <link href="/2020/02/01/%E9%9A%8F%E7%AC%94/hello-2020/"/>
      <url>/2020/02/01/%E9%9A%8F%E7%AC%94/hello-2020/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>2020 年加油!!! </p></blockquote><a id="more"></a><div class="note info">            <ul><li>研究go-micro微服务架构</li><li>研究ClickHouse</li><li>MySQL 8.0上线</li><li>MongoDB 4.2上线</li><li>Codis上云</li></ul>          </div><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译和链接</title>
      <link href="/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/"/>
      <url>/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>本文主要讲解编写完源代码之后，是如何生成可执行文件的。 </p></blockquote><a id="more"></a><p>一个程序的的生命周期从编写源代码开始，在编写完源代码之后，就可以进行代码的构建了。其中第一步就是编译, 编译阶段会生成各文件的目标文件，将生成的目标文件和系统库文件进行链接，最终生成了可以在特定平台运行的可执行文件。最后操作系统装载器会加载、解包这些数据，并将这些数据用于程序的执行阶段。</p><div class="note info">            <p>程序的生命周期简化</p><ul><li>编写源代码</li><li>编译</li><li>链接</li><li>装载</li><li>执行</li></ul>          </div><h1 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从广义上来讲，编译就是讲一种编程语言源代码转换为另一种编程语言描述的源代码。</p><ul><li>编译器负责编译程序。</li><li>编译器的输入时一个编译单元。通常编译单元指的是一个包含源代码的文本文件。</li><li>一个程序通常包含多个编译单元。</li><li>编译过程的输出是一系列二进制目标文件的集合，其中每一个目标文件对应一个作为输入的编译单元。</li></ul><p>我们通常会遇到以下几个相关概念：</p><ul><li>编译：从严格意义上讲，编译指的是讲高级语言编写的源代码翻译成低级语言描述代码的过程。</li><li>交叉编译：如果在一个平台(相同CPU或者操作系统)上进行的编译，生成的代码可以在其他平台上面执行，那么这种编译过程就称为交叉编译。</li><li>反编译：降低级语言编写的源代码转换成高级语言描述的源代码的过程。</li></ul><h2 id="编译的各个阶段"><a href="#编译的各个阶段" class="headerlink" title="编译的各个阶段"></a>编译的各个阶段</h2><ol><li>预处理阶段</li><li>语言分析阶段</li><li>汇编阶段</li><li>优化阶段</li><li>代码生成阶段</li></ol><h2 id="目标文件属性"><a href="#目标文件属性" class="headerlink" title="目标文件属性"></a>目标文件属性</h2><p>编译阶段的输出是一个或者多个目标文件，以下分析这些目标文件的结构。</p><ul><li>目标文件是通过其对应的源代码编译得到。</li><li>符号(symbol)和节(section)是目标文件的基本组成部分，其中符号表示的是程序中的内存地址或者数据内存。绝大多数的目标文件中包含代码节(.text)、初始化数据节(.data)、未初始化数据节(.bss)以及一些特殊节(比如试调信息等)。</li><li>构建程序的目的在于将编译的每个独立的源代码文件生成节拼接到一个二进制可执行文件中。最终生成的二进制文件中包含了多个相同类型的节(.text、.data 和 .bss节等)，而这些节是从每个独立的目标文件中拼接得到的。</li><li>目标文件中独立的节都可能包含在最终的程序内存映射中，因此目标文件中每个节的起始地址都会被临时设置成0，等待连接时调整。在程序构建过程的后续阶段(链接阶段)中会确认程序内存映射中每个独立节的实际地址范围。</li><li>在将目标文件的节拼接到程序内存映射的过程中。其中唯一重要的参数是节的长度，准确的说是节的地址范围。</li><li>目标文件中不包含专门的节会影响堆和栈中的数据。内存映射中的堆和栈内容完全在运行时确定，除了需要指定堆和栈的默认长度以外，并不需要程序指定任何其他初始化设置。</li><li>目标文件只包含了程序.bss(未初始化数据)节的基本信息， 而.bss节本身也仅仅只有字节的长度信息。装载器会利用这有限的数据为.bss节建立足够其数据存储的内存空间。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来讲，目标文件中的信息是根据一组特定的二进制格式规范集合进行存储的，其中范围定义了多种不同平台的细节信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制格式规范的设计通常是为了支持C/C++语言结构并帮助其解决实现问题。二进制格式规范常常会涵盖各种各样的文件类型，比如可执行文件、静态库和动态库等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Linux上，可执行和可链接格式(Executable and Linkable Format, ELF)已经得到了普遍运用。在Windows上，二进制文件通常遵循PE/COFF格式规范。</p><div class="note info">            <h2 id="为什么要进行编译？"><a href="#为什么要进行编译？" class="headerlink" title="为什么要进行编译？"></a>为什么要进行编译？</h2><p>答：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前很多语言实现了一阶段式构建过程, 比如：python，javaScripts。<br>为了程序构建阶段支持复用(此处指的是二进制级别的复用)，所以将程序构建分为两个阶段(编译阶段和链接阶段)。</p>          </div><h1 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h1><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接过程第一个阶段仅仅进行拼接，其过程是将分散在单独目标文件中不同类型的节拼接到程序内存映射节中。</p><p>如下图所示：</p><img src="/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/link-01.png" class="" title="图1 链接第一步： 重定向"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了完成该任务，需要将之前预留的空间，也就是节中从0开始的地址范围转换成最终程序的内存映射中更具体的地址范围。</p><h2 id="解析引用"><a href="#解析引用" class="headerlink" title="解析引用"></a>解析引用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将节的地址范围转换成程序内存映射地址范围，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gcc -c function.c main.c</span></span><br><span class="line"><span class="meta"># gcc funtion.o main.o -o demoApp</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gcc function.c main.c -o demoApp</span></span><br></pre></td></tr></table></figure><p>反汇编main.o文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># objdump -D -M intel main.o</span></span><br></pre></td></tr></table></figure><p>对含有未初始化数据的.bss节进行反汇编操作，发现变量nCompletionStatus</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># objdump -x -j .bss demoApp</span></span><br></pre></td></tr></table></figure><h1 id="可执行文件属性"><a href="#可执行文件属性" class="headerlink" title="可执行文件属性"></a>可执行文件属性</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接过程的最终结果是二进制可执行文件，其结构布局遵循特定目标平台的可执行文件格式。</p><p>启动代码有两种不同形式：</p><ul><li>crt0 是程序入口点，这是程序代码的第一部分，在内核控制下执行。</li><li>crt1 是启动例程(startuproutine)，可以在main函数执行前与程序终止后完成一些任务。</li></ul><p>程序可执行文件的整体结构大致如下图：</p><img src="/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/link-02.png" class="" title="图2 可执行文件的整体结构"><h2 id="各种节的类型"><a href="#各种节的类型" class="headerlink" title="各种节的类型"></a>各种节的类型</h2><p>待补充…</p><h2 id="各种符号类型"><a href="#各种符号类型" class="headerlink" title="各种符号类型"></a>各种符号类型</h2><p>待补充…</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从存储器到内存映射布局</title>
      <link href="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/"/>
      <url>/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>从存储器到内存映射布局 </p></blockquote><a id="more"></a><p>在日常工作中，经常会有同学提出这样的问题，</p><ul><li>“我的程序运行时究竟占用了多大的内存?”</li><li>“我的程序占用的虚拟内存非常大，这个正常么?”</li></ul><div class="note info">            <p>本文主要从以下几个方向，深入浅出的说明内存的基本布局，后续会更新内存的管理的文章。</p><ul><li>计算机体系结构</li><li>存储器缓存策略</li><li>虚拟内存</li><li>虚拟地址</li><li>进程的内存划分方案</li></ul>          </div><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机技术领域的变化日新月异，集成电路技术带来的元件不仅种类繁多，而且在功能方面还在不断改进增强。按照摩尔定律，集成电路上可容纳的晶体管数目大约每两年便会增加一倍。而与晶体管数据量密切相关的处理能力也将提升一倍。</p><p>经验告诉我们，想要应对这种快速的变化，就是在经常变动的实现层次之上，利用抽象和泛华的方法为计算机系统定义全局目标和结构体系。这种方法的核心在于描述抽象的方式，该方式要确保在去除相对无关的实现细节后，任何新的实现与核心定义都能保持一致。</p><p>整个计算机体系结构可用下图表示:</p><img src="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/os_abstract.png" class=""><p>在计算机系统中，有一些和存储器相关的趣事：</p><ul><li>人们对存储器容量总是无法满足，而且存储器容量总是供不应求。</li><li>存储器技术似乎是导致处理器性能障碍的主要原因<br>– 这种被称为”处理器和存储器之间的速度鸿沟(The processor-memory gap)”</li><li>存储器的访问能力与其存储容量成反比。</li></ul><h2 id="存储器缓存策略"><a href="#存储器缓存策略" class="headerlink" title="存储器缓存策略"></a>存储器缓存策略</h2><p>我们从程序员、设计师和工程师的角度，我们希望系统能够以最快的速度访问所有可用存储器。<br>但是这个基本上是不可能的，实际上系统并不是使用所有的存储器，而是仅仅是在某些时段内使用某一部分存储器。这个情况下，只需要为程序预留相对最快的存储器，而让那些并非立即执行的代码或者数据使用相对较慢的存储器。当CPU立即需要执行指令时，在执行到存储在较慢的存储器上的代码之前，这些代码会转存在较快的存储器中，这种策略称为”缓存”。</p><p>缓存策略无处不在，横跨多个级别的存储器，如下图所示：</p><img src="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/memory_en.png" class=""><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>我们用名为”进程”的抽象概念来表示正在运行的程序。现在多任务操作系统的设计允许一个或者多个用户并发地运行多个程序，对于一个普通用户来说，同时运行多个应用程序（比如听歌、看网页、编辑文档）在正常不过了。</p><p>通过虚拟内存的概念，可以很好的解决内存需求与有限的内存容量之间的矛盾，运行时的物理内存会被划分成数个小的分段（页），每个页都可以用来同步执行程序。正在运行的程序的完整内存布局会被保存在低速存储器（磁盘）中。只有那些当前即将被执行的一部分内存（代码和数据）才会被加载到物理内存页中。</p><p>首先需要强调的是虚拟内存不同于物理内存，二者属于不同层面的东西。<br>进程占用虚拟内存空间大并非意味着程序的物理内存也一定占用很大。虚拟内存是操作系统内核为了对进程地址空间进行管理(process address space management)而设计的一个逻辑意义上的内存空间概念，我们程序中的指针其实都是这个虚拟内存空间中的地址。</p><div class="note info">            <p><strong>虚拟地址</strong>(virtual address):</p><ul><li>CPU启动保护模式后，程序运行在虚拟地址空间中。</li><li>注意，并不是所有的“程序”都是运行在虚拟地址中。 </li><li>CPU在启动的时候是运行在实模式的，Bootloader以及内核在初始化页表之前并不使用虚拟地址，而是直接使用物理地址的。</li><li>虚拟地址范围：编程模型假定地址空间的范围在0到$2^N$，其中N是32或者64。</li></ul>          </div><p>比如我们写完一个C/C++项目之后，采用gcc/g++进行编译，这个时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时程序都没有开始运行，所以何谈物理内存空间地址？</p><p>凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中。既然说虚拟内存是一个逻辑意义上(逻辑存在)的内存空间，为了能够让程序在物理机器上运行起来，那就需要有一套机制可以让这些虚拟内存空间映射到物理内存空间(真实内存条上的空间)。</p><p>在Linux中，解决这个问题的关键是一个叫做 page table (PT页面转换表) 的结构。Linux把物理内存分为了固定统一大小的块，称为page(页)，一般为4KB，并且每个页都有一个编号”page frame number”。这样一个512M大小的内存将包括128K个页。这种方式称为paging，使得操作系统对内存的管理更方便。page table的作用就是将进程操作的地址(虚拟地址)转换成物理地址。</p><p>关于 page table 内容原理，可以参考以下文章。</p><div class="note info">            <p>Linux Page Tables ： <a href="http://www.linux-tutorial.info/modules.php?name=MContent&amp;pageid=307" target="_blank" rel="noopener">www.linux-tutorial.info/modules.php?name=MContent&amp;pageid=307</a></p>          </div><p>内核会为系统中每一个进程维护一份相互独立的页映射表，页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。</p><p>“页(page)”是虚拟内存空间向物理内存空间映射的基本单元。</p><p>虚拟内存的概念如下图所示：</p><img src="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/system-physical-memory.png" class="" title="图3 虚拟内存空间到物理内存空间的映射"><p>上图演示了虚拟内存空间和物理内存空间的相互关系。它们通过Page Table关联起来。</p><p>其中虚拟内存空间中着色部分分别被映射到了物理内存空间对应相同的着色的部分。而虚拟内存空间中灰色的部分表示在物理内存空间中没有与之对应的部分，也就是说灰色部分没有被映射到物理内存空间中。因为虚拟内存空间很大，可能其中很多部分在一次程序运行中根本不需要访问，所以也就没有必要讲虚拟内存空间中的这些部分映射到物理内存空间上。</p><p>那么，总结一下，虚拟内存就是一个逻辑存在的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。</p><h3 id="驻留内存"><a href="#驻留内存" class="headerlink" title="驻留内存"></a>驻留内存</h3><p>顾名思义是指那些被映射到进程虚拟内存空间的物理内存。上图3中，在系统物理内存空间中被着色的部分都是驻留内存。</p><p>比如，A1、A2、A3和A4是进程A的驻留内存；B1、B2和B3是进程B的驻留内存。</p><p>进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。</p><div class="note info">            <p>以下为具体示例：</p>          </div><p>操作系统：Linux（Redhat 7.4）</p><h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root(jihaodong)@redhat work]<span class="comment"># free</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      131455940    54627048    12895764      178028    63933128    76268692</span><br><span class="line">Swap:      32767996      134996    32633000</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Key</th><th align="left">Desc</th></tr></thead><tbody><tr><td align="center">Mem.total</td><td align="left">物理内存的总量</td></tr><tr><td align="center">Mem.used</td><td align="left">使用的物理内存的总量</td></tr><tr><td align="center">Mem.free</td><td align="left">空闲内存总量</td></tr><tr><td align="center">Mem.shared</td><td align="left">共享内存</td></tr><tr><td align="center">Mem.buff</td><td align="left">内核缓冲区使用的内存</td></tr><tr><td align="center">Mem.cache</td><td align="left">页面缓存和Slab分配器使用的内存</td></tr><tr><td align="center">Mem.available</td><td align="left">系统空闲内存 Mem.available = Mem.free + Mem.buff + Mem.cache</td></tr><tr><td align="center">Swap.total</td><td align="left">交换分区总大小，系统物理内存不够用时，与swap进行交换</td></tr><tr><td align="center">Swap.used</td><td align="left">已经被使用的交换分区大小</td></tr><tr><td align="center">Swap.free</td><td align="left">未被使用的交换分区大小</td></tr></tbody></table><h3 id="进程的TOP信息："><a href="#进程的TOP信息：" class="headerlink" title="进程的TOP信息："></a>进程的TOP信息：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root(jihaodong)@redhat work]<span class="comment"># top -d 1 </span></span><br><span class="line">top - 14:30:32 up 28 days,  2:25,  1 user,  load average: 0.22, 0.31, 0.25</span><br><span class="line">Tasks: 398 total,   1 running, 397 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.5 us,  0.3 sy,  0.0 ni, 96.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : 13145593+total, 12901476 free, 54629708 used, 63924756 buff/cache</span><br><span class="line">KiB Swap: 32767996 total, 32632996 free,   135000 used. 76267056 avail Mem </span><br><span class="line">  scroll coordinates: y = 1/398 (tasks), x = 1/12 (fields)</span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                            </span><br><span class="line"> 5746 elastic+  20   0  0.233t 0.060t 0.011t S 100.0 48.8   7155:16 /opt/soft/jdk/jdk1.8.0_66/bin/java -Xms48g -Xmx48g -XX:+UseConcMa+ </span><br><span class="line">31299 root      20   0 4283448 305600   2368 S   0.0  0.2  51:26.88 java -XX:PermSize=128m -XX:MaxPermSize=256m -Xms512m -Xmx512m -cp+ </span><br><span class="line"> 7104 elastic+  20   0 1277408  99848   6260 S   0.0  0.1  93:41.92 ./bin/../node/bin/node --no-warnings ./bin/../src/cli              </span><br><span class="line">18809 root      20   0 2921264  47312   4168 S  10.0  0.0 294:00.58 /usr/<span class="built_in">local</span>/bin/xcdc run s1.js                                      </span><br><span class="line">18811 root      20   0 2663044  45584   4124 S   5.0  0.0 286:10.11 /usr/<span class="built_in">local</span>/bin/xcdc run s3.js                                      </span><br><span class="line">18810 root      20   0 2724032  45428   3980 S   5.0  0.0 298:59.47 /usr/<span class="built_in">local</span>/bin/xcdc run s2.js                                      </span><br><span class="line">18813 root      20   0 2930092  44012   4116 S   5.0  0.0 288:44.38 /usr/<span class="built_in">local</span>/bin/xcdc run s5.js                                      </span><br><span class="line">18812 root      20   0 2924452  43312   4024 S   0.0  0.0 291:19.32 /usr/<span class="built_in">local</span>/bin/xcdc run s4.js                                      </span><br><span class="line">10189 root      20   0 2350900  29800   2444 S   0.0  0.0  38:41.39 ./falcon-agent -c cfg.json</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Key</th><th align="left">Desc</th></tr></thead><tbody><tr><td align="center">PID</td><td align="left">进程ID</td></tr><tr><td align="center">PPID</td><td align="left">父进程ID</td></tr><tr><td align="center">UID</td><td align="left">进程所有者的用户ID</td></tr><tr><td align="center">USER</td><td align="left">进程所有者的用户名</td></tr><tr><td align="center">PR</td><td align="left">优先级</td></tr><tr><td align="center">NI</td><td align="left">NICE值，负值表示搞优先级，正值表示优先级底</td></tr><tr><td align="center">VIRT</td><td align="left">进程所用的虚拟内存总量， VIRT = SWAP + RES</td></tr><tr><td align="center">SWAP</td><td align="left">进程使用的虚拟内存中，被置换出去的大小</td></tr><tr><td align="center">RES</td><td align="left">进程使用的，未被置换出去的物理内存，（目前占用物理内存的值）</td></tr><tr><td align="center">SHR</td><td align="left">共享内存大小</td></tr></tbody></table><p>搞清楚了虚拟内存的概念之后解释VIRT就很简单了，VIRT表示虚拟内存空间大小结合图1(计算机体系结构抽象），对应到图3(虚拟内存空间到物理内存空间的映射）中来说就是A1、A2、A3、A4以及灰色部分所有空间的总和。也就是说虚拟包含了在已经映射到物理内存空间的部分和尚未映射到物理内存空间的部分的总和。</p><p>RES的含义是指进程虚拟内存空间中已经映射到物理内存空间的那部分的大小。对应到图1中的进程A来说就是A1、A2、A3以及A4几个部分空间的总和。所以说，看进程在运行过程中占用了多少内存应该看RES的值而不是VIRT的值。</p><p>最后来看看SHR所表示的含义。SHR是share（共享）的缩写，它表示的是进程占用的共享内存大小。在上图1中我们看到进程A虚拟内存空间中的A4和进程B虚拟内存空间中的B3都映射到了物理内存空间的A4/B3部分。咋一看很奇怪。为什么会出现这样的情况呢？其实我们写的程序会依赖于很多外部的动态库（.so），比如libc.so、libld.so等等。这些动态库在内存中仅仅会保存/映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进展之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出现不同进程的虚拟内存空间会映射到相同的物理内存空间。这部分物理内存空间其实是被多个进程所共享的，所以我们将他们称为共享内存，用SHR来表示。某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。所以要计算进程独占内存的大小只要用RES的值减去SHR值即可。</p><p>这片文章主要简单讲解Linux下进程的内存映射布局。</p><p>内存管理是操作系统的核心; 这对于编程和系统管理都至关重要。</p><h2 id="进程的内存划分方案"><a href="#进程的内存划分方案" class="headerlink" title="进程的内存划分方案"></a>进程的内存划分方案</h2><p>本节主要讨论进程内存映射的内部组织细节，我们假定的程序地址空间的范围在0到$2^N$，其中N是32或者64。</p><p>不同的多任务或者多用户操作系统拥有不同的内存映射布局。对于Linux进程的虚拟内存映射来说，其遵循图4所示的映射方案。</p><img src="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/linux-process-memory.png" class="" title="图3 虚拟内存空间到物理内存空间的映射"><p>无论平台的进程内存划分方案多么特殊，下面几个内存映射的节(section)都是必须支持的:</p><ul><li>代码节：该段包含了供CPU执行的机器码指令(.text节)。</li><li>数据节：该段包含了供CPU操作的数据。通常来说，初始化数据(.data节)、为初始化数据(.bss节)和只读数据(.rdata节)会保存在分离的节中。</li><li>堆：动态内存分配的区域。</li><li>栈：为各个函数提供了独立的存储空间。</li><li>最上层部分属于内核区域，特定进程的环境变量就存放在该区域。</li></ul><h2 id="二进制文件、编译器、连接器与装载器的作用"><a href="#二进制文件、编译器、连接器与装载器的作用" class="headerlink" title="二进制文件、编译器、连接器与装载器的作用"></a>二进制文件、编译器、连接器与装载器的作用</h2><p>粗略地讲：</p><ul><li>程序的二进制文件中包含了程序运行过程中的内存映射布局的细节。</li><li>链接器创建了二进制文件的整体框架。要实现这项功能，链接器要对编译器生成的二进制文件进行合并，然后想各个内存映射节填充信息(代码和数据等信息)。</li><li>进程内存映射的初始化建立工作是由程序装载器这一系统工具完成的。在最简单的情况下，装载器会打开二进制可执行文件，读取节的相关信息，然后将这些信息载入进程内存映射结构中。</li></ul><p>所有现代操作系统都是按照这种角色分离的方式设计的。</p><p>需要注意的是，以上描述是一个粗略地描述。</p><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考:"></a>文章参考:</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1]: 探索 Linux 内存模型： https://www.ibm.com/developerworks/cn/linux/l-memmod/</span><br><span class="line">[2]: 理解VIRT/RES/SHR之间的关系: http://orchome.com/298</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP使用Smart Pointer</title>
      <link href="/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/"/>
      <url>/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>CPP 引入 Smart Pointer 的原因，以及最佳实践 </p></blockquote><a id="more"></a><h2 id="Smart-Pointer-引入原因"><a href="#Smart-Pointer-引入原因" class="headerlink" title="Smart Pointer 引入原因"></a>Smart Pointer 引入原因</h2><p>使用 Raw Pointer 管理动态内存时，经常会遇到这样的问题：</p><ul><li>忘记delete内存，造成内存泄露</li><li>出现异常时，不会执行delete，造成内存泄露</li></ul><p>下面的代码解释了，当一个操作发生异常时，会导致delete不会被执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> Widget;</span><br><span class="line">    <span class="comment">// 执行一个会抛出异常的操作</span></span><br><span class="line">    func_throw_exception();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++98 中我们需要用一种笨拙的方式，写出异常安全的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> Widget;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        func_throw_exception();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        <span class="keyword">throw</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 使用 Smart Pointer 能轻易写出异常安全的代码，因为当对象退出作用域时, Smart Pointer 将自动调用对象的析构函数，避免内存泄露：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; ptr&#123; <span class="keyword">new</span> Widget &#125;;</span><br><span class="line">    func_throw_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Smart-Pointer-使用方法"><a href="#Smart-Pointer-使用方法" class="headerlink" title="Smart Pointer 使用方法"></a>Smart Pointer 使用方法</h2><p>Smart Pointer 在 <memory> 头文件的 std 名称空间中定义。 它们对于RAII或资源获取初始化编程惯用语至关重要。 这个习惯用法的主要目标是确保资源获取在对象被初始化的同时进行，以便在一行代码中创建和准备对象的所有资源。 实际上，RAII的主要原则是将任何堆分配的资源（例如，动态分配的内存或系统对象句柄）归属给一个堆栈分配的对象，该对象的析构函数包含删除或释放资源的代码， 还有任何相关的清理代码。</p><p>在大多数情况下，初始化 Raw Pointer 或资源句柄以指向实际资源时，请立即将指针传递给Smart Pointer。在现代C++中，Raw Pointer 仅用于有限范围，循环或辅助函数的小代码块，其中性能至关重要，并且不存在对所有权混淆的可能性。</p><p>以下示例将 Raw Pointer 声明与 Smart Pointer 声明进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Raw Pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseRawPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 Raw Pointer -- 不推荐 </span></span><br><span class="line">    Song* pSong = <span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pSong...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完成后，不要忘记释放申请的空间</span></span><br><span class="line">    <span class="keyword">delete</span> pSong;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Smart Pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseSmartPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在堆栈上声明一个 Smart Pointer 并将其传递给 Raw Pointer  -- 推荐</span></span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Song&gt; <span class="title">song2</span><span class="params">(<span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use song2...</span></span><br><span class="line">    <span class="built_in">wstring</span> s = song2-&gt;duration_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// song2 该程序块执行完后自动删除</span></span><br></pre></td></tr></table></figure><p>如示例中所示， Smart Pointer 是您在堆栈中声明的类模板，并使用指向堆分配对象的 Raw Pointer 进行初始化。 Smart Pointer 初始化后，它拥有 Raw Pointer 。这意味着 Smart Pointer 负责删除 Raw Pointer 指定的内存。 Smart Pointer 析构函数包含对删除的调用，并且因为 Smart Pointer 在堆栈中声明，所以当 Smart Pointer 超出作用域时，即使在堆栈之后的某处抛出异常，也会调用析构函数。</p><p>通过使用熟悉的指针操作符 -&gt; 和 * 来访问封装的指针， Smart Pointer 类重载该指针来返回封装的 Raw Pointer 。</p><p>C++ Smart Pointer 的对象创建：您创建对象，然后让系统在正确的时间删除它。不同之处在于没有单独的垃圾收集器在后台运行; 内存通过标准C++范围规则进行管理，以便运行时环境更快，更高效。</p><div class="note info">            <p>总是在单独的代码行上创建Smart Pointer，而不是在参数列表中创建，以便由于某些参数列表分配规则而不会发生细微的资源泄漏。</p>          </div><p>以下示例显示了如何使用标准模板库中的unique_ptrSmart Pointer类型来封装指向大对象的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessLargeObject</span><span class="params">(<span class="keyword">const</span> LargeObject&amp; lo)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass a reference to a method.</span></span><br><span class="line">    ProcessLargeObject(*pLarge);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//pLarge is deleted automatically when function block goes out of scope.</span></span><br></pre></td></tr></table></figure><p>该示例演示了使用 Smart Pointer 的以下基本步骤:</p><div class="note info">            <ul><li>将Smart Pointer声明为自动（本地）变量<br>– 不要在Smart Pointer本身上使用new 或 malloc 表达式</li><li>在类型参数中，指定封装指针的指向类型</li><li>将一个Raw Pointer传递给Smart Pointer构造函数中的新对象<br>– Some utility functions or smart pointer constructors do this for you </li><li>使用重载的 -&gt; 和 * 运算符来访问该对象</li><li>让 Smart Pointer 删除对象</li></ul>          </div><p>Smart Pointer 的设计在内存和性能方面尽可能高效。 例如，unique_ptr中唯一的数据成员是封装的指针。 这意味着 unique_ptr 与该指针的大小完全相同，可以是四个字节，也可以是八个字节。 通过使用Smart Pointer重载的 * 和 -&gt; 操作符访问封装的指针不会比直接访问 Raw Pointer 慢得多。</p><p>Smart Pointer有自己的成员函数，可以用“.”符号来访问。 例如，一些STL Smart Pointer有一个 reset member function ，释放指针的所有权。 如果您想在 Smart Pointer 超出范围之前释放 Smart Pointer 所拥有的内存，这非常有用，如下例所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the memory before we exit function block.</span></span><br><span class="line">    pLarge.reset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some other work...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Smart-Pointer-类型"><a href="#Smart-Pointer-类型" class="headerlink" title="Smart Pointer 类型"></a>Smart Pointer 类型</h2><ul><li>** unique_ptr **<ul><li>仅允许一个底层指针的所有者</li><li>可以移动到新的所有者，但不能复制或共享</li><li>unique_ptr小而高效, 大小是一个指针</li><li>它支持右值引用，以便从STL集合中快速插入和检索</li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li><li>** shared_ptr **<ul><li>引用计数的Smart Pointer</li><li>当您想要将一个Raw Pointer分配给多个所有者时使用，例如，当您从容器中返回指针的副本但想保留Raw Pointer时。 直到所有shared_ptr所有者超出范围或放弃所有权之后，才会删除Raw Pointer</li><li>大小是两个指针, 一个用于对象，另一个用于包含引用计数的共享控制块</li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li><li>** weak_ptr **<ul><li>与shared_ptr结合使用的特例Smart Pointer</li><li>weak_ptr 提供对一个或多个shared_ptr实例拥有的对象的访问权限，但不参与引用计数</li><li>当你想观察一个物体时使用，但不要求它保持活着。在某些情况下需要中断shared_ptr实例之间的循环引用。 </li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li></ul><h2 id="创建和使用unique-ptr实例"><a href="#创建和使用unique-ptr实例" class="headerlink" title="创建和使用unique_ptr实例"></a>创建和使用unique_ptr实例</h2><p>A unique_ptr不会共享它的指针。 无法将它复制到另一个unique_ptr，（除非它是可修改rvalue） 通过值传递给函数，或需要对其进行复制的任何标准模板库 (STL) 算法中使用。 A unique_ptr只能移动。 这意味着内存资源的所有权将转移到新的unique_ptr和原始unique_ptr不再拥有它。 我们建议您将一个对象限制为一个所有者，因为拥有多个程序逻辑增加复杂性。 因此，当您需要为普通的 C++ 对象的 Smart Pointer ，使用unique_ptr。</p><p>下图说明了两个转让所有权unique_ptr实例。</p><img src="/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/unique_ptr.png" class="" title="unique_ptr"><p>移动 unique_ptr 的所有权, unique_ptr在中定义<memory> STL 中的标头。 它是完全有效与 Raw Pointer ，可以使用 STL 容器中。 添加unique_ptr是有效的实例的 STL 容器因为移动构造函数的unique_ptr不需要复制操作。</p><p>** 示例 **<br>下面的示例演示如何创建unique_ptr实例，并在函数之间传递它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Created by Eter J on 2017/12/31.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::Foo\n"</span>; &#125;</span><br><span class="line">    ~Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::~Foo\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::bar\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Foo &amp;foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(const Foo&amp;)\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;  <span class="comment">// p1 owns Foo</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;bar();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; <span class="title">p2</span><span class="params">(<span class="built_in">std</span>::move(p1))</span></span>;  <span class="comment">// now p2 owns Foo</span></span><br><span class="line">        f(*p2);</span><br><span class="line"></span><br><span class="line">        p1 = <span class="built_in">std</span>::move(p2);  <span class="comment">// ownership returns to p1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroying p2...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;bar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Foo instance is destroyed when p1 goes out of scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Song&gt; <span class="title">SongFactory</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">wstring</span> artist, <span class="built_in">std</span>::<span class="built_in">wstring</span> title)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implicit move operation into the variable that stores the result. </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(artist, title));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeSongs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new unique_ptr with a new object.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Song&gt; pSong = <span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Mr. Children"</span>, <span class="string">L"Namonaki Uta"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the unique_ptr</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">wstring</span>&gt; titles;</span><br><span class="line">    titles.push_back(pSong-&gt;title);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move raw pointer from one unique_ptr to another.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Song&gt; pSong2 = <span class="built_in">std</span>::move(pSong);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain unique_ptr from function that returns rvalue reference.</span></span><br><span class="line">    <span class="keyword">auto</span> pSong3 = SongFactory(<span class="string">L"Michael Jackson"</span>, <span class="string">L"Beat It"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些例子演示了unique_ptr的基本特征：它可以被移动，但不能被复制。 “移动”将所有权转移到新的unique_ptr并重置旧的unique_ptr。</p><p>以下示例显示如何创建unique_ptr实例并在矢量中使用它们</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SongVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;Song&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a few new unique_ptr&lt;Song&gt; instances </span></span><br><span class="line">    <span class="comment">// and add them to vector using implicit move semantics.</span></span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"B'z"</span>, <span class="string">L"Juice"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Namie Amuro"</span>, <span class="string">L"Funky Town"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Kome Kome Club"</span>, <span class="string">L"Kimi ga Iru Dake de"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Ayumi Hamasaki"</span>, <span class="string">L"Poker Face"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass by reference to lambda body. </span></span><br><span class="line">    for_each(v.begin(), v.end(), [] (<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&lt;Song&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Artist: "</span> &lt;&lt; p-&gt;artist &lt;&lt; <span class="string">L"Title: "</span> &lt;&lt; p-&gt;title &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for_each循环中，请注意unique_ptr是在lambda表达式中通过引用传递的。 如果你尝试在这里传值，编译器会抛出一个错误，因为unique_ptr拷贝构造函数被禁用。</p><p>以下示例显示如何初始化一个类成员unique_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// MyClass owns the unique_ptr.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;ClassFactory&gt; factory;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize by invoking the unique_ptr move constructor.</span></span><br><span class="line">    MyClass() : factory ( <span class="built_in">unique_ptr</span>&lt;ClassFactory&gt;(<span class="keyword">new</span> ClassFactory()))</span><br><span class="line">    &#123;              </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        factory-&gt;DoSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info">            <ul><li>仅允许一个底层指针的所有者</li><li>可以移动到新的所有者，但不能复制或共享</li></ul>          </div><h2 id="创建和使用shared-ptr实例"><a href="#创建和使用shared-ptr实例" class="headerlink" title="创建和使用shared_ptr实例"></a>创建和使用shared_ptr实例</h2><p>shared_ptr 类型是 Smart Pointer 在为方案设计多个所有者可能必须管理对象生存期内存中的 C++ 标准库中。 在初始化可以将它复制的 shared_ptr 后，将它在函数参数的值，并将其分配给其他 shared_ptr 实例。 所有实例指向同一对象，并且，对“的共享访问控制块”该引用计数的增量和减量，每当新 shared_ptr 添加，超出范围或重新设置。 当引用计数达到零时，控制块删除内存资源和自身。</p><p>下图显示了指向个内存位置的几 shared_ptr 实例。</p><img src="/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/shared_ptr.png" class="" title="shared_ptr"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Eter J on 2017/12/31.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;C&gt; gp;</span><br><span class="line">    &#123;</span><br><span class="line">        C* ptr = <span class="keyword">new</span> C;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;C&gt; <span class="title">sp</span><span class="params">(ptr)</span></span>;</span><br><span class="line">        gp = sp ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp.use_count(): "</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"gp.use_count(): "</span> &lt;&lt; gp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"gp.use_count(): "</span> &lt;&lt; gp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OUTPUT:</p><blockquote><p>sp.use_count(): 1<br>gp.use_count(): 2<br>gp.use_count(): 1</p></blockquote><h2 id="创建和使用weak-ptr实例"><a href="#创建和使用weak-ptr实例" class="headerlink" title="创建和使用weak_ptr实例"></a>创建和使用weak_ptr实例</h2><p>有时一个对象必须存储一个访问shared_ptr的底层对象的方法，而不会导致引用计数增加。通常情况下，如果在shared_ptr实例之间有循环引用，则会发生这种情况。</p><p>最好的设计是尽可能避免指针的共享所有权。但是，如果您必须共享shared_ptr实例的所有权，请避免它们之间的循环引用。当循环引用是不可避免的，或者由于某种原因更可取的时候，使用weak_ptr来给一个或多个所有者一个弱引用给另一个shared_ptr。通过使用weak_ptr，您可以创建一个shared_ptr，它将连接到现有的一组相关实例，但前提是基础内存资源仍然有效。 weak_ptr本身不参与引用计数，因此它不能阻止引用计数变为零。但是，可以使用weak_ptr尝试获取初始化的shared_ptr的新副本。如果内存已被删除，则抛出bad_weak_ptr异常。如果内存仍然有效，那么只要shared_ptr变量保持在作用域内，新的共享指针就会增加引用计数并保证内存有效。</p><p>下面的代码示例演示了weak_ptr用于确保正确删除具有循环依赖关系的对象的情况。当你检查这个例子时，假设它只是在考虑了其他解决方案之后才创建的。 Controller对象表示机器进程的某些方面，它们独立运行。每个控制器必须能够随时查询其他控制器的状态，并且每个控制器都包含一个专用矢量<code>&lt;weak_ptr &lt;Controller&gt;&gt;</code>。每个向量包含一个循环引用，因此，使用weak_ptr实例而不是shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Eter J on 2018/1/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    <span class="built_in">wstring</span> Status;</span><br><span class="line">    <span class="built_in">vector</span>&lt;weak_ptr&lt;Controller&gt;&gt; others;</span><br><span class="line">    explicit Controller(int i) : Num(i) , Status(L"On")</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Creating Controller"</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Controller()</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Destroying Controller"</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstrates how to test whether the</span></span><br><span class="line">    <span class="comment">// pointed-to memory still exists or not.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckStatuses</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        for_each(others.begin(), others.end(), [] (weak_ptr&lt;Controller&gt; wp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = wp.lock();</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"Status of "</span> &lt;&lt; p-&gt;Num &lt;&lt; <span class="string">" = "</span> &lt;&lt; p-&gt;Status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (bad_weak_ptr b)</span><br><span class="line">            &#123;</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"Null object"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Controller&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">0</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">1</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">2</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">3</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">4</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Each controller depends on all others not being deleted.</span></span><br><span class="line">    <span class="comment">// Give each controller a pointer to all the others.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; v.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for_each(v.begin(), v.end(), [v,i] (<span class="built_in">shared_ptr</span>&lt;Controller&gt; p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;Num != i)</span><br><span class="line">            &#123;</span><br><span class="line">                v[i]-&gt;others.push_back(weak_ptr&lt;Controller&gt;(p));</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"push_back to v["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; p-&gt;Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for_each(v.begin(), v.end(), [](<span class="built_in">shared_ptr</span>&lt;Controller&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"use_count = "</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p-&gt;CheckStatuses();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RunTest();</span><br><span class="line">    wcout &lt;&lt; <span class="string">L"Press any key"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>.getline(&amp;ch, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OUTPUT</p><blockquote><p>Creating Controller0<br>Creating Controller1<br>Creating Controller2<br>Creating Controller3<br>Creating Controller4<br>push_back to v[0]: 1<br>push_back to v[0]: 2<br>push_back to v[0]: 3<br>push_back to v[0]: 4<br>push_back to v[1]: 0<br>push_back to v[1]: 2<br>push_back to v[1]: 3<br>push_back to v[1]: 4<br>push_back to v[2]: 0<br>push_back to v[2]: 1<br>push_back to v[2]: 3<br>push_back to v[2]: 4<br>push_back to v[3]: 0<br>push_back to v[3]: 1<br>push_back to v[3]: 2<br>push_back to v[3]: 4<br>push_back to v[4]: 0<br>push_back to v[4]: 1<br>push_back to v[4]: 2<br>push_back to v[4]: 3<br>use_count = 1<br>Status of 1 = On<br>Status of 2 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 2 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 2 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 2 = On<br>Status of 3 = On<br>Destroying Controller4<br>Destroying Controller3<br>Destroying Controller2<br>Destroying Controller1<br>Destroying Controller0<br>Press any key</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> Smart Pointers </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
